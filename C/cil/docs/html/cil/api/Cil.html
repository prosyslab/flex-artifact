<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="Start" href="index.html">
<link rel="previous" href="Cfg.html">
<link rel="next" href="Cillower.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of class types" rel=Appendix href="index_class_types.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Alpha" rel="Chapter" href="Alpha.html">
<link title="Cfg" rel="Chapter" href="Cfg.html">
<link title="Cil" rel="Chapter" href="Cil.html">
<link title="Cillower" rel="Chapter" href="Cillower.html">
<link title="Clist" rel="Chapter" href="Clist.html">
<link title="Dataflow" rel="Chapter" href="Dataflow.html">
<link title="Dominators" rel="Chapter" href="Dominators.html">
<link title="Errormsg" rel="Chapter" href="Errormsg.html">
<link title="Feature" rel="Chapter" href="Feature.html">
<link title="Formatcil" rel="Chapter" href="Formatcil.html">
<link title="Pretty" rel="Chapter" href="Pretty.html">
<link title="Stats" rel="Chapter" href="Stats.html"><title>CIL API Documentation  : Cil</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Cfg.html" title="Cfg">Previous</a>
&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;<a class="post" href="Cillower.html" title="Cillower">Next</a>
</div>
<h1>Module <a href="type_Cil.html">Cil</a></h1>

<pre><span id="MODULECil"><span class="keyword">module</span> Cil</span>: <code class="code">sig</code> <a href="Cil.html">..</a> <code class="code">end</code></pre><hr width="100%">
<p><b>CIL API Documentation.</b></p>

<pre><span id="VALinitCIL"><span class="keyword">val</span> initCIL</span> : <code class="type">unit -> unit</code></pre><div class="info ">
<div class="info-desc">
<p>Call this function to perform some initialization. Call if after you have
 set <a href="Cil.html#VALmsvcMode"><code class="code">Cil.msvcMode</code></a>.</p>
</div>
</div>

<pre><span id="VALcilVersion"><span class="keyword">val</span> cilVersion</span> : <code class="type">string</code></pre><div class="info ">
<div class="info-desc">
<p>These are the CIL version numbers. A CIL version is a number of the form
 M.m.r (major, minor and release)</p>
</div>
</div>

<pre><span id="VALcilVersionMajor"><span class="keyword">val</span> cilVersionMajor</span> : <code class="type">int</code></pre>
<pre><span id="VALcilVersionMinor"><span class="keyword">val</span> cilVersionMinor</span> : <code class="type">int</code></pre>
<pre><span id="VALcilVersionRevision"><span class="keyword">val</span> cilVersionRevision</span> : <code class="type">int</code></pre><p>This module defines the abstract syntax of CIL. It also provides utility
 functions for traversing the CIL data structures, and pretty-printing
 them. The parser for both the GCC and MSVC front-ends can be invoked as
 <code class="code">Frontc.parse: string -&gt; unit -&gt;</code> <a href="Cil.html#TYPEfile"><code class="code">Cil.file</code></a>. This function must be given
 the name of a preprocessed C file and will return the top-level data
 structure that describes a whole source file. By default the parsing and
 elaboration into CIL is done as for GCC source. If you want to use MSVC
 source you must set the <a href="Cil.html#VALmsvcMode"><code class="code">Cil.msvcMode</code></a> to <code class="code">true</code> and must also invoke the
 function <code class="code">Frontc.setMSVCMode: unit -&gt; unit</code>.</p>
<p><b>The Abstract Syntax of CIL</b></p>
<p>The top-level representation of a CIL source file (and the result of the
 parsing and elaboration). Its main contents is the list of global
 declarations and definitions. You can iterate over the globals in a
 <a href="Cil.html#TYPEfile"><code class="code">Cil.file</code></a> using the following iterators: <a href="Cil.html#VALmapGlobals"><code class="code">Cil.mapGlobals</code></a>,
 <a href="Cil.html#VALiterGlobals"><code class="code">Cil.iterGlobals</code></a> and <a href="Cil.html#VALfoldGlobals"><code class="code">Cil.foldGlobals</code></a>. You can also use the
 <a href="Cil.html#VALdummyFile"><code class="code">Cil.dummyFile</code></a> when you need a <a href="Cil.html#TYPEfile"><code class="code">Cil.file</code></a> as a placeholder. For each
 global item CIL stores the source location where it appears (using the
 type <a href="Cil.html#TYPElocation"><code class="code">Cil.location</code></a>)</p>

<pre><code><span id="TYPEfile"><span class="keyword">type</span> <code class="type"></code>file</span> = {</code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTfile.fileName">fileName</span>&nbsp;: <code class="type">string</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>The complete file name</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTfile.globals">globals</span>&nbsp;: <code class="type"><a href="Cil.html#TYPEglobal">global</a> list</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>List of globals as they will appear
                                      in the printed file</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTfile.globinit">globinit</span>&nbsp;: <code class="type"><a href="Cil.html#TYPEfundec">fundec</a> option</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>An optional global initializer function. This is a function where
 you can put stuff that must be executed before the program is
 started. This function is conceptually at the end of the file,
 although it is not part of the globals list. Use <a href="Cil.html#VALgetGlobInit"><code class="code">Cil.getGlobInit</code></a>
 to create/get one.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTfile.globinitcalled">globinitcalled</span>&nbsp;: <code class="type">bool</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>Whether the global initialization function is called in main. This
 should always be false if there is no global initializer. When you
 create a global initialization CIL will try to insert code in main
 to call it. This will not happen if your file does not contain a
 function called "main"</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
}

<div class="info ">
<div class="info-desc">
<p>Top-level representation of a C source file</p>
</div>
</div>


<pre><span id="TYPEcomment"><span class="keyword">type</span> <code class="type"></code>comment</span> = <code class="type"><a href="Cil.html#TYPElocation">location</a> * string</code> </pre>

<p><b>Globals</b>. The main type for representing global declarations and
 definitions. A list of these form a CIL file. The order of globals in the
 file is generally important.</p>

<pre><code><span id="TYPEglobal"><span class="keyword">type</span> <code class="type"></code>global</span> = </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTglobal.GType"><span class="constructor">GType</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEtypeinfo">typeinfo</a> * <a href="Cil.html#TYPElocation">location</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>A typedef. All uses of type names (through the <code class="code">TNamed</code> constructor)
      must be preceded in the file by a definition of the name. The string
      is the defined name and always not-empty.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTglobal.GCompTag"><span class="constructor">GCompTag</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEcompinfo">compinfo</a> * <a href="Cil.html#TYPElocation">location</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>Defines a struct/union tag with some fields. There must be one of
      these for each struct/union tag that you use (through the <code class="code">TComp</code>
      constructor) since this is the only context in which the fields are
      printed. Consequently nested structure tag definitions must be
      broken into individual definitions with the innermost structure
      defined first.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTglobal.GCompTagDecl"><span class="constructor">GCompTagDecl</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEcompinfo">compinfo</a> * <a href="Cil.html#TYPElocation">location</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>Declares a struct/union tag. Use as a forward declaration. This is
 printed without the fields.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTglobal.GEnumTag"><span class="constructor">GEnumTag</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEenuminfo">enuminfo</a> * <a href="Cil.html#TYPElocation">location</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>Declares an enumeration tag with some fields. There must be one of
      these for each enumeration tag that you use (through the <code class="code">TEnum</code>
      constructor) since this is the only context in which the items are
      printed.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTglobal.GEnumTagDecl"><span class="constructor">GEnumTagDecl</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEenuminfo">enuminfo</a> * <a href="Cil.html#TYPElocation">location</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>Declares an enumeration tag. Use as a forward declaration. This is
 printed without the items.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTglobal.GVarDecl"><span class="constructor">GVarDecl</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEvarinfo">varinfo</a> * <a href="Cil.html#TYPElocation">location</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>A variable declaration (not a definition). If the variable has a
      function type then this is a prototype. There can be several
      declarations and at most one definition for a given variable. If both
      forms appear then they must share the same varinfo structure. A
      prototype shares the varinfo with the fundec of the definition. Either
      has storage Extern or there must be a definition in this file</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTglobal.GVar"><span class="constructor">GVar</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEvarinfo">varinfo</a> * <a href="Cil.html#TYPEinitinfo">initinfo</a> * <a href="Cil.html#TYPElocation">location</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>A variable definition. Can have an initializer. The initializer is
 updateable so that you can change it without requiring to recreate
 the list of globals. There can be at most one definition for a
 variable in an entire program. Cannot have storage Extern or function
 type. Note: the initializer field is kept for backwards compatibility,
 but it is now also available directly in the varinfo.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTglobal.GFun"><span class="constructor">GFun</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEfundec">fundec</a> * <a href="Cil.html#TYPElocation">location</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>A function definition.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTglobal.GAsm"><span class="constructor">GAsm</span></span> <span class="keyword">of</span> <code class="type">string * <a href="Cil.html#TYPElocation">location</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>Global asm statement. These ones
                                            can contain only a template</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTglobal.GPragma"><span class="constructor">GPragma</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEattribute">attribute</a> * <a href="Cil.html#TYPElocation">location</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>Pragmas at top level. Use the same
                                            syntax as attributes</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTglobal.GText"><span class="constructor">GText</span></span> <span class="keyword">of</span> <code class="type">string</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>Some text (printed verbatim) at
                                            top level. E.g., this way you can
                                            put comments in the output.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info ">
<div class="info-desc">
<p>A global declaration or definition</p>
</div>
</div>

<p><b>Types</b>. A C type is represented in CIL using the type <a href="Cil.html#TYPEtyp"><code class="code">Cil.typ</code></a>.
 Among types we differentiate the integral types (with different kinds
 denoting the sign and precision), floating point types, enumeration types,
 array and pointer types, and function types. Every type is associated with
 a list of attributes, which are always kept in sorted order. Use
 <a href="Cil.html#VALaddAttribute"><code class="code">Cil.addAttribute</code></a> and <a href="Cil.html#VALaddAttributes"><code class="code">Cil.addAttributes</code></a> to construct list of
 attributes. If you want to inspect a type, you should use
 <a href="Cil.html#VALunrollType"><code class="code">Cil.unrollType</code></a> or <a href="Cil.html#VALunrollTypeDeep"><code class="code">Cil.unrollTypeDeep</code></a> to see through the uses of
 named types.</p>
<p>CIL is configured at build-time with the sizes and alignments of the
 underlying compiler (GCC or MSVC). CIL contains functions that can compute
 the size of a type (in bits) <a href="Cil.html#VALbitsSizeOf"><code class="code">Cil.bitsSizeOf</code></a>, the alignment of a type
 (in bytes) <a href="Cil.html#VALalignOf_int"><code class="code">Cil.alignOf_int</code></a>, and can convert an offset into a start and
 width (both in bits) using the function <a href="Cil.html#VALbitsOffset"><code class="code">Cil.bitsOffset</code></a>. At the moment
 these functions do not take into account the <code class="code">packed</code> attributes and
 pragmas.</p>

<pre><code><span id="TYPEtyp"><span class="keyword">type</span> <code class="type"></code>typ</span> = </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTtyp.TVoid"><span class="constructor">TVoid</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEattributes">attributes</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>Void type. Also predefined as <a href="Cil.html#VALvoidType"><code class="code">Cil.voidType</code></a></p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTtyp.TInt"><span class="constructor">TInt</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEikind">ikind</a> * <a href="Cil.html#TYPEattributes">attributes</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>An integer type. The kind specifies the sign and width. Several
 useful variants are predefined as <a href="Cil.html#VALintType"><code class="code">Cil.intType</code></a>, <a href="Cil.html#VALuintType"><code class="code">Cil.uintType</code></a>,
 <a href="Cil.html#VALlongType"><code class="code">Cil.longType</code></a>, <a href="Cil.html#VALcharType"><code class="code">Cil.charType</code></a>.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTtyp.TFloat"><span class="constructor">TFloat</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEfkind">fkind</a> * <a href="Cil.html#TYPEattributes">attributes</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>A floating-point type. The kind specifies the precision. You can
 also use the predefined constant <a href="Cil.html#VALdoubleType"><code class="code">Cil.doubleType</code></a>.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTtyp.TPtr"><span class="constructor">TPtr</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEtyp">typ</a> * <a href="Cil.html#TYPEattributes">attributes</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>Pointer type. Several useful variants are predefined as
 <a href="Cil.html#VALcharPtrType"><code class="code">Cil.charPtrType</code></a>, <a href="Cil.html#VALcharConstPtrType"><code class="code">Cil.charConstPtrType</code></a> (pointer to a
 constant character), <a href="Cil.html#VALvoidPtrType"><code class="code">Cil.voidPtrType</code></a>,
 <a href="Cil.html#VALintPtrType"><code class="code">Cil.intPtrType</code></a></p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTtyp.TArray"><span class="constructor">TArray</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEtyp">typ</a> * <a href="Cil.html#TYPEexp">exp</a> option * <a href="Cil.html#TYPEattributes">attributes</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>Array type. It indicates the base type and the array length.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTtyp.TFun"><span class="constructor">TFun</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEtyp">typ</a> * (string * <a href="Cil.html#TYPEtyp">typ</a> * <a href="Cil.html#TYPEattributes">attributes</a>) list option * bool<br>        * <a href="Cil.html#TYPEattributes">attributes</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>Function type. Indicates the type of the result, the name, type
 and name attributes of the formal arguments (<code class="code">None</code> if no
 arguments were specified, as in a function whose definition or
 prototype we have not seen; <code class="code">Some []</code> means void). Use
 <a href="Cil.html#VALargsToList"><code class="code">Cil.argsToList</code></a> to obtain a list of arguments. The boolean
 indicates if it is a variable-argument function. If this is the
 type of a varinfo for which we have a function declaration then
 the information for the formals must match that in the
 function's sformals. Use <a href="Cil.html#VALsetFormals"><code class="code">Cil.setFormals</code></a>, or
 <a href="Cil.html#VALsetFunctionType"><code class="code">Cil.setFunctionType</code></a>, or <a href="Cil.html#VALmakeFormalVar"><code class="code">Cil.makeFormalVar</code></a> for this
 purpose.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTtyp.TNamed"><span class="constructor">TNamed</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEtypeinfo">typeinfo</a> * <a href="Cil.html#TYPEattributes">attributes</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>The use of a named type. Each such type name must be preceded
 in the file by a <code class="code">GType</code> global. This is printed as just the
 type name. The actual referred type is not printed here and is
 carried only to simplify processing. To see through a sequence
 of named type references, use <a href="Cil.html#VALunrollType"><code class="code">Cil.unrollType</code></a> or
 <a href="Cil.html#VALunrollTypeDeep"><code class="code">Cil.unrollTypeDeep</code></a>. The attributes are in addition to those
 given when the type name was defined.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTtyp.TComp"><span class="constructor">TComp</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEcompinfo">compinfo</a> * <a href="Cil.html#TYPEattributes">attributes</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>The most delicate issue for C types is that recursion that is possible by
 using structures and pointers. To address this issue we have a more
 complex representation for structured types (struct and union). Each such
 type is represented using the <a href="Cil.html#TYPEcompinfo"><code class="code">Cil.compinfo</code></a> type. For each composite
 type the <a href="Cil.html#TYPEcompinfo"><code class="code">Cil.compinfo</code></a> structure must be declared at top level using
 <code class="code">GCompTag</code> and all references to it must share the same copy of the
 structure. The attributes given are those pertaining to this use of the
 type and are in addition to the attributes that were given at the
 definition of the type and which are stored in the <a href="Cil.html#TYPEcompinfo"><code class="code">Cil.compinfo</code></a>.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTtyp.TEnum"><span class="constructor">TEnum</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEenuminfo">enuminfo</a> * <a href="Cil.html#TYPEattributes">attributes</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>A reference to an enumeration type. All such references must
      share the enuminfo among them and with a <code class="code">GEnumTag</code> global that
      precedes all uses. The attributes refer to this use of the
      enumeration and are in addition to the attributes of the
      enumeration itself, which are stored inside the enuminfo</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTtyp.TBuiltin_va_list"><span class="constructor">TBuiltin_va_list</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEattributes">attributes</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>This is the same as the gcc's type with the same name</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>


<p>There are a number of functions for querying the kind of a type. These are
   <a href="Cil.html#VALisIntegralType"><code class="code">Cil.isIntegralType</code></a>,
   <a href="Cil.html#VALisArithmeticType"><code class="code">Cil.isArithmeticType</code></a>,
   <a href="Cil.html#VALisPointerType"><code class="code">Cil.isPointerType</code></a>,
   <a href="Cil.html#VALisScalarType"><code class="code">Cil.isScalarType</code></a>,
   <a href="Cil.html#VALisFunctionType"><code class="code">Cil.isFunctionType</code></a>,
   <a href="Cil.html#VALisArrayType"><code class="code">Cil.isArrayType</code></a>.</p>

<p>There are two easy ways to scan a type. First, you can use the
   <a href="Cil.html#VALexistsType"><code class="code">Cil.existsType</code></a> to return a boolean answer about a type. This function
   is controlled by a user-provided function that is queried for each type that is
   used to construct the current type. The function can specify whether to
   terminate the scan with a boolean result or to continue the scan for the
   nested types.</p>

<p>The other method for scanning types is provided by the visitor interface (see
   <a href="Cil.cilVisitor-c.html"><code class="code">Cil.cilVisitor</code></a>).</p>

<p>If you want to compare types (or to use them as hash-values) then you should
   use instead type signatures (represented as <a href="Cil.html#TYPEtypsig"><code class="code">Cil.typsig</code></a>). These
   contain the same information as types but canonicalized such that simple Ocaml
   structural equality will tell whether two types are equal. Use
   <a href="Cil.html#VALtypeSig"><code class="code">Cil.typeSig</code></a> to compute the signature of a type. If you want to ignore
   certain type attributes then use <a href="Cil.html#VALtypeSigWithAttrs"><code class="code">Cil.typeSigWithAttrs</code></a>.</p>

<pre><code><span id="TYPEikind"><span class="keyword">type</span> <code class="type"></code>ikind</span> = </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTikind.IChar"><span class="constructor">IChar</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p><code class="code">char</code></p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTikind.ISChar"><span class="constructor">ISChar</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p><code class="code">signed char</code></p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTikind.IUChar"><span class="constructor">IUChar</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p><code class="code">unsigned char</code></p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTikind.IBool"><span class="constructor">IBool</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p><code class="code">_Bool (C99)</code></p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTikind.IInt"><span class="constructor">IInt</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p><code class="code">int</code></p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTikind.IUInt"><span class="constructor">IUInt</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p><code class="code">unsigned int</code></p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTikind.IShort"><span class="constructor">IShort</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p><code class="code">short</code></p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTikind.IUShort"><span class="constructor">IUShort</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p><code class="code">unsigned short</code></p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTikind.ILong"><span class="constructor">ILong</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p><code class="code">long</code></p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTikind.IULong"><span class="constructor">IULong</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p><code class="code">unsigned long</code></p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTikind.ILongLong"><span class="constructor">ILongLong</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p><code class="code">long long</code> (or <code class="code">_int64</code> on Microsoft Visual C)</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTikind.IULongLong"><span class="constructor">IULongLong</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p><code class="code">unsigned long long</code> (or <code class="code">unsigned _int64</code> on Microsoft
                    Visual C)</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info ">
<div class="info-desc">
<p>Various kinds of integers</p>
</div>
</div>


<pre><code><span id="TYPEfkind"><span class="keyword">type</span> <code class="type"></code>fkind</span> = </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTfkind.FFloat"><span class="constructor">FFloat</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p><code class="code">float</code></p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTfkind.FDouble"><span class="constructor">FDouble</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p><code class="code">double</code></p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTfkind.FLongDouble"><span class="constructor">FLongDouble</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p><code class="code">long double</code></p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info ">
<div class="info-desc">
<p>Various kinds of floating-point numbers</p>
</div>
</div>

<p><b>Attributes.</b></p>

<pre><code><span id="TYPEattribute"><span class="keyword">type</span> <code class="type"></code>attribute</span> = </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTattribute.Attr"><span class="constructor">Attr</span></span> <span class="keyword">of</span> <code class="type">string * <a href="Cil.html#TYPEattrparam">attrparam</a> list</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>An attribute has a name and some optional parameters. The name should not
 start or end with underscore. When CIL parses attribute names it will
 strip leading and ending underscores (to ensure that the multitude of GCC
 attributes such as const, __const and __const__ all mean the same thing.)</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>



<pre><span id="TYPEattributes"><span class="keyword">type</span> <code class="type"></code>attributes</span> = <code class="type"><a href="Cil.html#TYPEattribute">attribute</a> list</code> </pre>
<div class="info ">
<div class="info-desc">
<p>Attributes are lists sorted by the attribute name. Use the functions
 <a href="Cil.html#VALaddAttribute"><code class="code">Cil.addAttribute</code></a> and <a href="Cil.html#VALaddAttributes"><code class="code">Cil.addAttributes</code></a> to insert attributes in an
 attribute list and maintain the sortedness.</p>
</div>
</div>


<pre><code><span id="TYPEattrparam"><span class="keyword">type</span> <code class="type"></code>attrparam</span> = </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTattrparam.AInt"><span class="constructor">AInt</span></span> <span class="keyword">of</span> <code class="type">int</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>An integer constant</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTattrparam.AStr"><span class="constructor">AStr</span></span> <span class="keyword">of</span> <code class="type">string</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>A string constant</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTattrparam.ACons"><span class="constructor">ACons</span></span> <span class="keyword">of</span> <code class="type">string * <a href="Cil.html#TYPEattrparam">attrparam</a> list</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>Constructed attributes. These
                                               are printed <code class="code">foo(a1,a2,...,an)</code>.
                                               The list of parameters can be
                                               empty and in that case the
                                               parentheses are not printed.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTattrparam.ASizeOf"><span class="constructor">ASizeOf</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEtyp">typ</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>A way to talk about types</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTattrparam.ASizeOfE"><span class="constructor">ASizeOfE</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEattrparam">attrparam</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTattrparam.ASizeOfS"><span class="constructor">ASizeOfS</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEtypsig">typsig</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>Replacement for ASizeOf in type
                                             signatures.  Only used for
                                             attributes inside typsigs.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTattrparam.AAlignOf"><span class="constructor">AAlignOf</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEtyp">typ</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTattrparam.AAlignOfE"><span class="constructor">AAlignOfE</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEattrparam">attrparam</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTattrparam.AAlignOfS"><span class="constructor">AAlignOfS</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEtypsig">typsig</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTattrparam.AUnOp"><span class="constructor">AUnOp</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEunop">unop</a> * <a href="Cil.html#TYPEattrparam">attrparam</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTattrparam.ABinOp"><span class="constructor">ABinOp</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEbinop">binop</a> * <a href="Cil.html#TYPEattrparam">attrparam</a> * <a href="Cil.html#TYPEattrparam">attrparam</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTattrparam.ADot"><span class="constructor">ADot</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEattrparam">attrparam</a> * string</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>a.foo *</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTattrparam.AStar"><span class="constructor">AStar</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEattrparam">attrparam</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>a</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTattrparam.AAddrOf"><span class="constructor">AAddrOf</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEattrparam">attrparam</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>&amp; a *</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTattrparam.AIndex"><span class="constructor">AIndex</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEattrparam">attrparam</a> * <a href="Cil.html#TYPEattrparam">attrparam</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>a1<code class="code">a2</code></p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTattrparam.AQuestion"><span class="constructor">AQuestion</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEattrparam">attrparam</a> * <a href="Cil.html#TYPEattrparam">attrparam</a> * <a href="Cil.html#TYPEattrparam">attrparam</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>a1 ? a2 : a3 *</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info ">
<div class="info-desc">
<p>The type of parameters of attributes</p>
</div>
</div>

<p><b>Structures.</b> The <a href="Cil.html#TYPEcompinfo"><code class="code">Cil.compinfo</code></a> describes the definition of a
 structure or union type. Each such <a href="Cil.html#TYPEcompinfo"><code class="code">Cil.compinfo</code></a> must be defined at the
 top-level using the <code class="code">GCompTag</code> constructor and must be shared by all
 references to this type (using either the <code class="code">TComp</code> type constructor or from
 the definition of the fields.</p>

<p>If all you need is to scan the definition of each
 composite type once, you can do that by scanning all top-level <code class="code">GCompTag</code>.</p>

<p>Constructing a <a href="Cil.html#TYPEcompinfo"><code class="code">Cil.compinfo</code></a> can be tricky since it must contain fields
 that might refer to the host <a href="Cil.html#TYPEcompinfo"><code class="code">Cil.compinfo</code></a> and furthermore the type of
 the field might need to refer to the <a href="Cil.html#TYPEcompinfo"><code class="code">Cil.compinfo</code></a> for recursive types.
 Use the <a href="Cil.html#VALmkCompInfo"><code class="code">Cil.mkCompInfo</code></a> function to create a <a href="Cil.html#TYPEcompinfo"><code class="code">Cil.compinfo</code></a>. You can
 easily fetch the <a href="Cil.html#TYPEfieldinfo"><code class="code">Cil.fieldinfo</code></a> for a given field in a structure with
 <a href="Cil.html#VALgetCompField"><code class="code">Cil.getCompField</code></a>.</p>

<pre><code><span id="TYPEcompinfo"><span class="keyword">type</span> <code class="type"></code>compinfo</span> = {</code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTcompinfo.cstruct">cstruct</span>&nbsp;: <code class="type">bool</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>True if struct, False if union</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTcompinfo.cname">cname</span>&nbsp;: <code class="type">string</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>The name. Always non-empty. Use <a href="Cil.html#VALcompFullName"><code class="code">Cil.compFullName</code></a> to get the full
 name of a comp (along with the struct or union)</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTcompinfo.ckey">ckey</span>&nbsp;: <code class="type">int</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>A unique integer. This is assigned by <a href="Cil.html#VALmkCompInfo"><code class="code">Cil.mkCompInfo</code></a> using a
 global variable in the Cil module. Thus two identical structs in two
 different files might have different keys. Use <a href="Cil.html#VALcopyCompInfo"><code class="code">Cil.copyCompInfo</code></a> to
 copy structures so that a new key is assigned.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTcompinfo.cfields">cfields</span>&nbsp;: <code class="type"><a href="Cil.html#TYPEfieldinfo">fieldinfo</a> list</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>Information about the fields. Notice that each fieldinfo has a
 pointer back to the host compinfo. This means that you should not
 share fieldinfo's between two compinfo's</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTcompinfo.cattr">cattr</span>&nbsp;: <code class="type"><a href="Cil.html#TYPEattributes">attributes</a></code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>The attributes that are defined at the same time as the composite
 type. These attributes can be supplemented individually at each
 reference to this <code class="code">compinfo</code> using the <code class="code">TComp</code> type constructor.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTcompinfo.cdefined">cdefined</span>&nbsp;: <code class="type">bool</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>This boolean flag can be used to distinguish between structures
      that have not been defined and those that have been defined but have
      no fields (such things are allowed in gcc).</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTcompinfo.creferenced">creferenced</span>&nbsp;: <code class="type">bool</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>True if used. Initially set to false.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
}

<div class="info ">
<div class="info-desc">
<p>The definition of a structure or union type. Use <a href="Cil.html#VALmkCompInfo"><code class="code">Cil.mkCompInfo</code></a> to
 make one and use <a href="Cil.html#VALcopyCompInfo"><code class="code">Cil.copyCompInfo</code></a> to copy one (this ensures that a new
 key is assigned and that the fields have the right pointers to parents.).</p>
</div>
</div>

<p><b>Structure fields.</b> The <a href="Cil.html#TYPEfieldinfo"><code class="code">Cil.fieldinfo</code></a> structure is used to describe
 a structure or union field. Fields, just like variables, can have
 attributes associated with the field itself or associated with the type of
 the field (stored along with the type of the field).</p>

<pre><code><span id="TYPEfieldinfo"><span class="keyword">type</span> <code class="type"></code>fieldinfo</span> = {</code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTfieldinfo.fcomp">fcomp</span>&nbsp;: <code class="type"><a href="Cil.html#TYPEcompinfo">compinfo</a></code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>The host structure that contains this field. There can be only one
 <code class="code">compinfo</code> that contains the field.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTfieldinfo.fname">fname</span>&nbsp;: <code class="type">string</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>The name of the field. Might be the value of <a href="Cil.html#VALmissingFieldName"><code class="code">Cil.missingFieldName</code></a>
 in which case it must be a bitfield and is not printed and it does not
 participate in initialization</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTfieldinfo.ftype">ftype</span>&nbsp;: <code class="type"><a href="Cil.html#TYPEtyp">typ</a></code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>The type</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTfieldinfo.fbitfield">fbitfield</span>&nbsp;: <code class="type">int option</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>If a bitfield then ftype should be an integer type and the width of
 the bitfield must be 0 or a positive integer smaller or equal to the
 width of the integer type. A field of width 0 is used in C to control
 the alignment of fields.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTfieldinfo.fattr">fattr</span>&nbsp;: <code class="type"><a href="Cil.html#TYPEattributes">attributes</a></code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>The attributes for this field (not for its type)</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTfieldinfo.floc">floc</span>&nbsp;: <code class="type"><a href="Cil.html#TYPElocation">location</a></code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>The location where this field is defined</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
}

<div class="info ">
<div class="info-desc">
<p>Information about a struct/union field</p>
</div>
</div>

<p><b>Enumerations.</b> Information about an enumeration. This is shared by all
 references to an enumeration. Make sure you have a <code class="code">GEnumTag</code> for each of
 of these.</p>

<pre><code><span id="TYPEenuminfo"><span class="keyword">type</span> <code class="type"></code>enuminfo</span> = {</code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTenuminfo.ename">ename</span>&nbsp;: <code class="type">string</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>The name. Always non-empty.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTenuminfo.eitems">eitems</span>&nbsp;: <code class="type">(string * <a href="Cil.html#TYPEexp">exp</a> * <a href="Cil.html#TYPElocation">location</a>) list</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>Items with names and values. This list should be non-empty. The item
 values must be compile-time constants.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTenuminfo.eattr">eattr</span>&nbsp;: <code class="type"><a href="Cil.html#TYPEattributes">attributes</a></code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>The attributes that are defined at the same time as the enumeration
 type. These attributes can be supplemented individually at each
 reference to this <code class="code">enuminfo</code> using the <code class="code">TEnum</code> type constructor.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTenuminfo.ereferenced">ereferenced</span>&nbsp;: <code class="type">bool</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>True if used. Initially set to false</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTenuminfo.ekind">ekind</span>&nbsp;: <code class="type"><a href="Cil.html#TYPEikind">ikind</a></code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>The integer kind used to represent this enum. Per ANSI-C, this
 should always be IInt, but gcc allows other integer kinds</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
}

<div class="info ">
<div class="info-desc">
<p>Information about an enumeration</p>
</div>
</div>


<pre><code><span id="TYPEtypeinfo"><span class="keyword">type</span> <code class="type"></code>typeinfo</span> = {</code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTtypeinfo.tname">tname</span>&nbsp;: <code class="type">string</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>The name. Can be empty only in a <code class="code">GType</code> when introducing a composite
 or enumeration tag. If empty cannot be referred to from the file</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTtypeinfo.ttype">ttype</span>&nbsp;: <code class="type"><a href="Cil.html#TYPEtyp">typ</a></code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>The actual type. This includes the attributes that were present in
 the typedef</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTtypeinfo.treferenced">treferenced</span>&nbsp;: <code class="type">bool</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>True if used. Initially set to false</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
}

<div class="info ">
<div class="info-desc">
<p>Information about a defined type</p>
</div>
</div>

<p><b>Variables.</b>
    Each local or global variable is represented by a unique <a href="Cil.html#TYPEvarinfo"><code class="code">Cil.varinfo</code></a>
    structure. A global <a href="Cil.html#TYPEvarinfo"><code class="code">Cil.varinfo</code></a> can be introduced with the <code class="code">GVarDecl</code> or
    <code class="code">GVar</code> or <code class="code">GFun</code> globals. A local varinfo can be introduced as part of a
    function definition <a href="Cil.html#TYPEfundec"><code class="code">Cil.fundec</code></a>.</p>

<p>All references to a given global or local variable must refer to the same
    copy of the <code class="code">varinfo</code>. Each <code class="code">varinfo</code> has a globally unique identifier that
    can be used to index maps and hashtables (the name can also be used for this
    purpose, except for locals from different functions). This identifier is
    constructor using a global counter.</p>

<p>It is very important that you construct <code class="code">varinfo</code> structures using only one
    of the following functions:</p>
<ul>
<li><a href="Cil.html#VALmakeGlobalVar"><code class="code">Cil.makeGlobalVar</code></a> : to make a global variable</li>
<li><a href="Cil.html#VALmakeTempVar"><code class="code">Cil.makeTempVar</code></a> : to make a temporary local variable whose name
    will be generated so that to avoid conflict with other locals.</li>
<li><a href="Cil.html#VALmakeLocalVar"><code class="code">Cil.makeLocalVar</code></a> : like <a href="Cil.html#VALmakeTempVar"><code class="code">Cil.makeTempVar</code></a> but you can specify the
    exact name to be used.</li>
<li><a href="Cil.html#VALcopyVarinfo"><code class="code">Cil.copyVarinfo</code></a>: make a shallow copy of a varinfo assigning a new name
    and a new unique identifier</li>
</ul>
<p>A <code class="code">varinfo</code> is also used in a function type to denote the list of formals.</p>

<pre><code><span id="TYPEvarinfo"><span class="keyword">type</span> <code class="type"></code>varinfo</span> = {</code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTvarinfo.vname">vname</span>&nbsp;: <code class="type">string</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>The name of the variable. Cannot be empty. It is primarily your
 responsibility to ensure the uniqueness of a variable name. For local
 variables <a href="Cil.html#VALmakeTempVar"><code class="code">Cil.makeTempVar</code></a> helps you ensure that the name is unique.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTvarinfo.vtype">vtype</span>&nbsp;: <code class="type"><a href="Cil.html#TYPEtyp">typ</a></code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>The declared type of the variable.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTvarinfo.vattr">vattr</span>&nbsp;: <code class="type"><a href="Cil.html#TYPEattributes">attributes</a></code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>A list of attributes associated with the variable.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTvarinfo.vstorage">vstorage</span>&nbsp;: <code class="type"><a href="Cil.html#TYPEstorage">storage</a></code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>The storage-class</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTvarinfo.vglob">vglob</span>&nbsp;: <code class="type">bool</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>True if this is a global variable</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTvarinfo.vinline">vinline</span>&nbsp;: <code class="type">bool</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>Whether this varinfo is for an inline function.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTvarinfo.vnoreturn">vnoreturn</span>&nbsp;: <code class="type">bool</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>Whether this varinfo is for a noreturn function.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTvarinfo.vdecl">vdecl</span>&nbsp;: <code class="type"><a href="Cil.html#TYPElocation">location</a></code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>Location of variable declaration.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTvarinfo.vinit">vinit</span>&nbsp;: <code class="type"><a href="Cil.html#TYPEinitinfo">initinfo</a></code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>Optional initializer.  Only used for static and global variables.
 Initializers for other types of local variables are turned into
 assignments. Not mutable because the init field in initinfo is mutable
 already.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTvarinfo.vid">vid</span>&nbsp;: <code class="type">int</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>A unique integer identifier. This field will be
 set for you if you use one of the <a href="Cil.html#VALmakeFormalVar"><code class="code">Cil.makeFormalVar</code></a>,
 <a href="Cil.html#VALmakeLocalVar"><code class="code">Cil.makeLocalVar</code></a>, <a href="Cil.html#VALmakeTempVar"><code class="code">Cil.makeTempVar</code></a>, <a href="Cil.html#VALmakeGlobalVar"><code class="code">Cil.makeGlobalVar</code></a>, or
 <a href="Cil.html#VALcopyVarinfo"><code class="code">Cil.copyVarinfo</code></a>.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTvarinfo.vaddrof">vaddrof</span>&nbsp;: <code class="type">bool</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>True if the address of this variable is taken. CIL will set these
 flags when it parses C, but you should make sure to set the flag
 whenever your transformation create <code class="code">AddrOf</code> expression.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTvarinfo.vreferenced">vreferenced</span>&nbsp;: <code class="type">bool</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>True if this variable is ever referenced. This is computed by
 <code class="code">Rmtmps.removeUnusedTemps</code>. It is safe to just initialize this to False</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTvarinfo.vdescr">vdescr</span>&nbsp;: <code class="type"><a href="Pretty.html#TYPEdoc">Pretty.doc</a></code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>For most temporary variables, a description of what the var holds.
  (e.g. for temporaries used for function call results, this string
   is a representation of the function call.)</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTvarinfo.vdescrpure">vdescrpure</span>&nbsp;: <code class="type">bool</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>Indicates whether the vdescr above is a pure expression or call.
  Printing a non-pure vdescr more than once may yield incorrect
  results.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
}

<div class="info ">
<div class="info-desc">
<p>Information about a variable.</p>
</div>
</div>


<pre><code><span id="TYPEstorage"><span class="keyword">type</span> <code class="type"></code>storage</span> = </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTstorage.NoStorage"><span class="constructor">NoStorage</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>The default storage. Nothing is printed</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTstorage.Static"><span class="constructor">Static</span></span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTstorage.Register"><span class="constructor">Register</span></span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTstorage.Extern"><span class="constructor">Extern</span></span></code></td>

</tr></table>

<div class="info ">
<div class="info-desc">
<p>Storage-class information</p>
</div>
</div>

<p><b>Expressions.</b> The CIL expression language contains only the side-effect free expressions of
    C. They are represented as the type <a href="Cil.html#TYPEexp"><code class="code">Cil.exp</code></a>. There are several
    interesting aspects of CIL expressions:</p>

<p>Integer and floating point constants can carry their textual representation.
    This way the integer 15 can be printed as 0xF if that is how it occurred in the
    source.</p>

<p>CIL uses 64 bits to represent the integer constants and also stores the width
    of the integer type. Care must be taken to ensure that the constant is
    representable with the given width. Use the functions <a href="Cil.html#VALkinteger"><code class="code">Cil.kinteger</code></a>,
    <a href="Cil.html#VALkinteger64"><code class="code">Cil.kinteger64</code></a> and <a href="Cil.html#VALinteger"><code class="code">Cil.integer</code></a> to construct constant
    expressions. CIL predefines the constants <a href="Cil.html#VALzero"><code class="code">Cil.zero</code></a>,
    <a href="Cil.html#VALone"><code class="code">Cil.one</code></a> and <a href="Cil.html#VALmone"><code class="code">Cil.mone</code></a> (for -1).</p>

<p>Use the functions <a href="Cil.html#VALisConstant"><code class="code">Cil.isConstant</code></a> and <a href="Cil.html#VALisInteger"><code class="code">Cil.isInteger</code></a> to test if
    an expression is a constant and a constant integer respectively.</p>

<p>CIL keeps the type of all unary and binary expressions. You can think of that
    type qualifying the operator. Furthermore there are different operators for
    arithmetic and comparisons on arithmetic types and on pointers.</p>

<p>Another unusual aspect of CIL is that the implicit conversion between an
    expression of array type and one of pointer type is made explicit, using the
    <code class="code">StartOf</code> expression constructor (which is not printed). If you apply the
    <code class="code">AddrOf}</code>constructor to an lvalue of type <code class="code">T</code> then you will be getting an
    expression of type <code class="code">TPtr(T)</code>.</p>

<p>You can find the type of an expression with <a href="Cil.html#VALtypeOf"><code class="code">Cil.typeOf</code></a>.</p>

<p>You can perform constant folding on expressions using the function
    <a href="Cil.html#VALconstFold"><code class="code">Cil.constFold</code></a>.</p>

<pre><code><span id="TYPEexp"><span class="keyword">type</span> <code class="type"></code>exp</span> = </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTexp.Const"><span class="constructor">Const</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEconstant">constant</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>Constant</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTexp.Lval"><span class="constructor">Lval</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPElval">lval</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>Lvalue</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTexp.SizeOf"><span class="constructor">SizeOf</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEtyp">typ</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>sizeof(&lt;type&gt;). Has <code class="code">unsigned int</code> type (ISO 6.5.3.4). This is not
 turned into a constant because some transformations might want to
 change types</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTexp.SizeOfE"><span class="constructor">SizeOfE</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEexp">exp</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>sizeof(&lt;expression&gt;)</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTexp.SizeOfStr"><span class="constructor">SizeOfStr</span></span> <span class="keyword">of</span> <code class="type">string</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>sizeof(string_literal). We separate this case out because this is the
 only instance in which a string literal should not be treated as
 having type pointer to character.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTexp.AlignOf"><span class="constructor">AlignOf</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEtyp">typ</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>This corresponds to the GCC __alignof_. Has <code class="code">unsigned int</code> type</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTexp.AlignOfE"><span class="constructor">AlignOfE</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEexp">exp</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTexp.UnOp"><span class="constructor">UnOp</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEunop">unop</a> * <a href="Cil.html#TYPEexp">exp</a> * <a href="Cil.html#TYPEtyp">typ</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>Unary operation. Includes the type of the result.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTexp.BinOp"><span class="constructor">BinOp</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEbinop">binop</a> * <a href="Cil.html#TYPEexp">exp</a> * <a href="Cil.html#TYPEexp">exp</a> * <a href="Cil.html#TYPEtyp">typ</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>Binary operation. Includes the type of the result. The arithmetic
 conversions are made explicit for the arguments.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTexp.Question"><span class="constructor">Question</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEexp">exp</a> * <a href="Cil.html#TYPEexp">exp</a> * <a href="Cil.html#TYPEexp">exp</a> * <a href="Cil.html#TYPEtyp">typ</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>(a ? b : c) operation. Includes the type of the result</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTexp.CastE"><span class="constructor">CastE</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEtyp">typ</a> * <a href="Cil.html#TYPEexp">exp</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>Use <a href="Cil.html#VALmkCast"><code class="code">Cil.mkCast</code></a> to make casts.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTexp.AddrOf"><span class="constructor">AddrOf</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPElval">lval</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>Always use <a href="Cil.html#VALmkAddrOf"><code class="code">Cil.mkAddrOf</code></a> to construct one of these. Apply to an
 lvalue of type <code class="code">T</code> yields an expression of type <code class="code">TPtr(T)</code>. Use
 <a href="Cil.html#VALmkAddrOrStartOf"><code class="code">Cil.mkAddrOrStartOf</code></a> to make one of these if you are not sure which
 one to use.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTexp.AddrOfLabel"><span class="constructor">AddrOfLabel</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEstmt">stmt</a> ref</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>The address of a label, using GCC's label-as-value extension.  If you
 want to use these, you must set <a href="Cil.html#VALuseComputedGoto"><code class="code">Cil.useComputedGoto</code></a>.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTexp.StartOf"><span class="constructor">StartOf</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPElval">lval</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>Conversion from an array to a pointer to the beginning of the array.
 Given an lval of type <code class="code">TArray(T)</code> produces an expression of type
 <code class="code">TPtr(T)</code>. Use <a href="Cil.html#VALmkAddrOrStartOf"><code class="code">Cil.mkAddrOrStartOf</code></a> to make one of these if you are
 not sure which one to use. In C this operation is implicit, the
 <code class="code">StartOf</code> operator is not printed. We have it in CIL because it makes
 the typing rules simpler.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info ">
<div class="info-desc">
<p>Expressions (Side-effect free)</p>
</div>
</div>

<p><b>Constants.</b></p>

<pre><code><span id="TYPEconstant"><span class="keyword">type</span> <code class="type"></code>constant</span> = </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTconstant.CInt64"><span class="constructor">CInt64</span></span> <span class="keyword">of</span> <code class="type">int64 * <a href="Cil.html#TYPEikind">ikind</a> * string option</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>Integer constant. Give the ikind (see ISO9899 6.1.3.2) and the
 textual representation, if available. (This allows us to print a
 constant as, for example, 0xF instead of 15.) Use <a href="Cil.html#VALinteger"><code class="code">Cil.integer</code></a> or
 <a href="Cil.html#VALkinteger"><code class="code">Cil.kinteger</code></a> to create these. Watch out for integers that cannot be
 represented on 64 bits. OCAML does not give Overflow exceptions.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTconstant.CStr"><span class="constructor">CStr</span></span> <span class="keyword">of</span> <code class="type">string</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>String constant. The escape characters inside the string have been
 already interpreted. This constant has pointer to character type! The
 only case when you would like a string literal to have an array type
 is when it is an argument to sizeof. In that case you should use
 SizeOfStr.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTconstant.CWStr"><span class="constructor">CWStr</span></span> <span class="keyword">of</span> <code class="type">int64 list</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>Wide character string constant. Note that the local interpretation
 of such a literal depends on <a href="Cil.html#VALwcharType"><code class="code">Cil.wcharType</code></a> and <a href="Cil.html#VALwcharKind"><code class="code">Cil.wcharKind</code></a>.
 Such a constant has type pointer to <a href="Cil.html#VALwcharType"><code class="code">Cil.wcharType</code></a>. The
 escape characters in the string have not been "interpreted" in
 the sense that L"A\xabcd" remains "A\xabcd" rather than being
 represented as the wide character list with two elements: 65 and
 43981. That "interpretation" depends on the underlying wide
 character type.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTconstant.CChr"><span class="constructor">CChr</span></span> <span class="keyword">of</span> <code class="type">char</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>Character constant.  This has type int, so use charConstToInt
 to read the value in case sign-extension is needed.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTconstant.CReal"><span class="constructor">CReal</span></span> <span class="keyword">of</span> <code class="type">float * <a href="Cil.html#TYPEfkind">fkind</a> * string option</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>Floating point constant. Give the fkind (see ISO 6.4.4.2) and also
 the textual representation, if available.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTconstant.CEnum"><span class="constructor">CEnum</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEexp">exp</a> * string * <a href="Cil.html#TYPEenuminfo">enuminfo</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>An enumeration constant with the given value, name, from the given
 enuminfo. This is used only if <a href="Cil.html#VALlowerConstants"><code class="code">Cil.lowerConstants</code></a> is true
 (default). Use <a href="Cil.html#VALconstFoldVisitor"><code class="code">Cil.constFoldVisitor</code></a> to replace these with integer
 constants.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info ">
<div class="info-desc">
<p>Literal constants</p>
</div>
</div>


<pre><code><span id="TYPEunop"><span class="keyword">type</span> <code class="type"></code>unop</span> = </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTunop.Neg"><span class="constructor">Neg</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>Unary minus</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTunop.BNot"><span class="constructor">BNot</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>Bitwise complement (~)</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTunop.LNot"><span class="constructor">LNot</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>Logical Not (!)</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info ">
<div class="info-desc">
<p>Unary operators</p>
</div>
</div>


<pre><code><span id="TYPEbinop"><span class="keyword">type</span> <code class="type"></code>binop</span> = </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTbinop.PlusA"><span class="constructor">PlusA</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>arithmetic +</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTbinop.PlusPI"><span class="constructor">PlusPI</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>pointer + integer</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTbinop.IndexPI"><span class="constructor">IndexPI</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>pointer + integer but only when
 it arises from an expression
 <code class="code">e[i]</code> when <code class="code">e</code> is a pointer and
 not an array. This is semantically
 the same as PlusPI but CCured uses
 this as a hint that the integer is
 probably positive.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTbinop.MinusA"><span class="constructor">MinusA</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>arithmetic -</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTbinop.MinusPI"><span class="constructor">MinusPI</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>pointer - integer</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTbinop.MinusPP"><span class="constructor">MinusPP</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>pointer - pointer</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTbinop.Mult"><span class="constructor">Mult</span></span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTbinop.Div"><span class="constructor">Div</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>/</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTbinop.Mod"><span class="constructor">Mod</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>%</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTbinop.Shiftlt"><span class="constructor">Shiftlt</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>shift left</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTbinop.Shiftrt"><span class="constructor">Shiftrt</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>shift right</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTbinop.Lt"><span class="constructor">Lt</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>&lt;  (arithmetic comparison)</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTbinop.Gt"><span class="constructor">Gt</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>&gt;  (arithmetic comparison)</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTbinop.Le"><span class="constructor">Le</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>&lt;= (arithmetic comparison)</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTbinop.Ge"><span class="constructor">Ge</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>&gt;  (arithmetic comparison)</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTbinop.Eq"><span class="constructor">Eq</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>== (arithmetic comparison)</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTbinop.Ne"><span class="constructor">Ne</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>!= (arithmetic comparison)</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTbinop.BAnd"><span class="constructor">BAnd</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>bitwise and</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTbinop.BXor"><span class="constructor">BXor</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>exclusive-or</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTbinop.BOr"><span class="constructor">BOr</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>inclusive-or</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTbinop.LAnd"><span class="constructor">LAnd</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>logical and. Unlike other
 expressions this one does not
 always evaluate both operands. If
 you want to use these, you must
 set <a href="Cil.html#VALuseLogicalOperators"><code class="code">Cil.useLogicalOperators</code></a>.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTbinop.LOr"><span class="constructor">LOr</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>logical or. Unlike other
 expressions this one does not
 always evaluate both operands.  If
 you want to use these, you must
 set <a href="Cil.html#VALuseLogicalOperators"><code class="code">Cil.useLogicalOperators</code></a>.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info ">
<div class="info-desc">
<p>Binary operations</p>
</div>
</div>

<p><b>Lvalues.</b> Lvalues are the sublanguage of expressions that can appear at the left of an assignment or as operand to the address-of operator.
    In C the syntax for lvalues is not always a good indication of the meaning
    of the lvalue. For example the C value</p>
<pre class="verbatim">a[0][1][2]
</pre><p>might involve 1, 2 or 3 memory reads when used in an expression context,
    depending on the declared type of the variable <code class="code">a</code>. If <code class="code">a</code> has type <code class="code">int
    [4][4][4]</code> then we have one memory read from somewhere inside the area
    that stores the array <code class="code">a</code>. On the other hand if <code class="code">a</code> has type <code class="code">int ***</code> then
    the expression really means <code class="code">* ( * ( * (a + 0) + 1) + 2)</code>, in which case it is
    clear that it involves three separate memory operations.</p>

<p>An lvalue denotes the contents of a range of memory addresses. This range
    is denoted as a host object along with an offset within the object. The
    host object can be of two kinds: a local or global variable, or an object
    whose address is in a pointer expression. We distinguish the two cases so
    that we can tell quickly whether we are accessing some component of a
    variable directly or we are accessing a memory location through a pointer.
    To make it easy to
    tell what an lvalue means CIL represents lvalues as a host object and an
    offset (see <a href="Cil.html#TYPElval"><code class="code">Cil.lval</code></a>). The host object (represented as
    <a href="Cil.html#TYPElhost"><code class="code">Cil.lhost</code></a>) can be a local or global variable or can be the object
    pointed-to by a pointer expression. The offset (represented as
    <a href="Cil.html#TYPEoffset"><code class="code">Cil.offset</code></a>) is a sequence of field or array index designators.</p>

<p>Both the typing rules and the meaning of an lvalue is very precisely
    specified in CIL.</p>

<p>The following are a few useful function for operating on lvalues:</p>
<ul>
<li><a href="Cil.html#VALmkMem"><code class="code">Cil.mkMem</code></a> - makes an lvalue of <code class="code">Mem</code> kind. Use this to ensure
    that certain equivalent forms of lvalues are canonized.
    For example, <code class="code">*&amp;x = x</code>.</li>
<li><a href="Cil.html#VALtypeOfLval"><code class="code">Cil.typeOfLval</code></a> - the type of an lvalue</li>
<li><a href="Cil.html#VALtypeOffset"><code class="code">Cil.typeOffset</code></a> - the type of an offset, given the type of the
    host.</li>
<li><a href="Cil.html#VALaddOffset"><code class="code">Cil.addOffset</code></a> and <a href="Cil.html#VALaddOffsetLval"><code class="code">Cil.addOffsetLval</code></a> - extend sequences
    of offsets.</li>
<li><a href="Cil.html#VALremoveOffset"><code class="code">Cil.removeOffset</code></a> and <a href="Cil.html#VALremoveOffsetLval"><code class="code">Cil.removeOffsetLval</code></a> - shrink sequences
    of offsets.</li>
</ul>
<p>The following equivalences hold</p>
<pre class="verbatim">Mem(AddrOf(Mem a, aoff)), off   = Mem a, aoff + off
Mem(AddrOf(Var v, aoff)), off   = Var v, aoff + off
AddrOf (Mem a, NoOffset)        = a
</pre>
<pre><span id="TYPElval"><span class="keyword">type</span> <code class="type"></code>lval</span> = <code class="type"><a href="Cil.html#TYPElhost">lhost</a> * <a href="Cil.html#TYPEoffset">offset</a></code> </pre>
<div class="info ">
<div class="info-desc">
<p>An lvalue</p>
</div>
</div>


<pre><code><span id="TYPElhost"><span class="keyword">type</span> <code class="type"></code>lhost</span> = </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTlhost.Var"><span class="constructor">Var</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEvarinfo">varinfo</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>The host is a variable.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTlhost.Mem"><span class="constructor">Mem</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEexp">exp</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>The host is an object of type <code class="code">T</code> when the expression has pointer
 <code class="code">TPtr(T)</code>.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info ">
<div class="info-desc">
<p>The host part of an <a href="Cil.html#TYPElval"><code class="code">Cil.lval</code></a>.</p>
</div>
</div>


<pre><code><span id="TYPEoffset"><span class="keyword">type</span> <code class="type"></code>offset</span> = </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELToffset.NoOffset"><span class="constructor">NoOffset</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>No offset. Can be applied to any lvalue and does
 not change either the starting address or the type.
 This is used when the lval consists of just a host
 or as a terminator in a list of other kinds of
 offsets.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELToffset.Field"><span class="constructor">Field</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEfieldinfo">fieldinfo</a> * <a href="Cil.html#TYPEoffset">offset</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>A field offset. Can be applied only to an lvalue
 that denotes a structure or a union that contains
 the mentioned field. This advances the offset to the
 beginning of the mentioned field and changes the
 type to the type of the mentioned field.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELToffset.Index"><span class="constructor">Index</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEexp">exp</a> * <a href="Cil.html#TYPEoffset">offset</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>An array index offset. Can be applied only to an
 lvalue that denotes an array. This advances the
 starting address of the lval to the beginning of the
 mentioned array element and changes the denoted type
 to be the type of the array element</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info ">
<div class="info-desc">
<p>The offset part of an <a href="Cil.html#TYPElval"><code class="code">Cil.lval</code></a>. Each offset can be applied to certain
 kinds of lvalues and its effect is that it advances the starting address
 of the lvalue and changes the denoted type, essentially focusing to some
 smaller lvalue that is contained in the original one.</p>
</div>
</div>

<p><b>Initializers.</b> A special kind of expressions are those that can appear
 as initializers for global variables (initialization of local variables is
 turned into assignments). The initializers are represented as type
 <a href="Cil.html#TYPEinit"><code class="code">Cil.init</code></a>. You can create initializers with <a href="Cil.html#VALmakeZeroInit"><code class="code">Cil.makeZeroInit</code></a> and you
 can conveniently scan compound initializers them with
 <a href="Cil.html#VALfoldLeftCompound"><code class="code">Cil.foldLeftCompound</code></a>.</p>

<pre><code><span id="TYPEinit"><span class="keyword">type</span> <code class="type"></code>init</span> = </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTinit.SingleInit"><span class="constructor">SingleInit</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEexp">exp</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>A single initializer</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTinit.CompoundInit"><span class="constructor">CompoundInit</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEtyp">typ</a> * (<a href="Cil.html#TYPEoffset">offset</a> * <a href="Cil.html#TYPEinit">init</a>) list</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>Used only for initializers of structures, unions and arrays. The
 offsets are all of the form <code class="code">Field(f, NoOffset)</code> or <code class="code">Index(i,
 NoOffset)</code> and specify the field or the index being initialized. For
 structures all fields must have an initializer (except the unnamed
 bitfields), in the proper order. This is necessary since the offsets
 are not printed. For unions there must be exactly one initializer. If
 the initializer is not for the first field then a field designator is
 printed, so you better be on GCC since MSVC does not understand this.
 For arrays, however, we allow you to give only a prefix of the
 initializers. You can scan an initializer list with
 <a href="Cil.html#VALfoldLeftCompound"><code class="code">Cil.foldLeftCompound</code></a>.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info ">
<div class="info-desc">
<p>Initializers for global variables.</p>
</div>
</div>


<pre><code><span id="TYPEinitinfo"><span class="keyword">type</span> <code class="type"></code>initinfo</span> = {</code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTinitinfo.init">init</span>&nbsp;: <code class="type"><a href="Cil.html#TYPEinit">init</a> option</code>;</code></td>

</tr></table>
}

<div class="info ">
<div class="info-desc">
<p>We want to be able to update an initializer in a variable, so we define it
 as a mutable field</p>
</div>
</div>

<p><b>Function definitions.</b>
    A function definition is always introduced with a <code class="code">GFun</code> constructor at the
    top level. All the information about the function is stored into a
    <a href="Cil.html#TYPEfundec"><code class="code">Cil.fundec</code></a>. Some of the information (e.g. its name, type,
    storage, attributes) is stored as a <a href="Cil.html#TYPEvarinfo"><code class="code">Cil.varinfo</code></a> that is a field of the
    <code class="code">fundec</code>. To refer to the function from the expression language you must use
    the <code class="code">varinfo</code>.</p>

<p>The function definition contains, in addition to the body, a list of all the
    local variables and separately a list of the formals. Both kind of variables
    can be referred to in the body of the function. The formals must also be shared
    with the formals that appear in the function type. For that reason, to
    manipulate formals you should use the provided functions
    <a href="Cil.html#VALmakeFormalVar"><code class="code">Cil.makeFormalVar</code></a> and <a href="Cil.html#VALsetFormals"><code class="code">Cil.setFormals</code></a> and <a href="Cil.html#VALmakeFormalVar"><code class="code">Cil.makeFormalVar</code></a>.</p>

<pre><code><span id="TYPEfundec"><span class="keyword">type</span> <code class="type"></code>fundec</span> = {</code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTfundec.svar">svar</span>&nbsp;: <code class="type"><a href="Cil.html#TYPEvarinfo">varinfo</a></code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>Holds the name and type as a variable, so we can refer to it
 easily from the program. All references to this function either
 in a function call or in a prototype must point to the same
 <code class="code">varinfo</code>.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTfundec.sformals">sformals</span>&nbsp;: <code class="type"><a href="Cil.html#TYPEvarinfo">varinfo</a> list</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>Formals. These must be in the same order and with the same
 information as the formal information in the type of the function.
 Use <a href="Cil.html#VALsetFormals"><code class="code">Cil.setFormals</code></a> or
 <a href="Cil.html#VALsetFunctionType"><code class="code">Cil.setFunctionType</code></a> or <a href="Cil.html#VALmakeFormalVar"><code class="code">Cil.makeFormalVar</code></a>
 to set these formals and ensure that they
 are reflected in the function type. Do not make copies of these
 because the body refers to them.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTfundec.slocals">slocals</span>&nbsp;: <code class="type"><a href="Cil.html#TYPEvarinfo">varinfo</a> list</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>Locals. Does NOT include the sformals. Do not make copies of
 these because the body refers to them.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTfundec.smaxid">smaxid</span>&nbsp;: <code class="type">int</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>Max local id. Starts at 0. Used for
 creating the names of new temporary
 variables. Updated by
 <a href="Cil.html#VALmakeLocalVar"><code class="code">Cil.makeLocalVar</code></a> and
 <a href="Cil.html#VALmakeTempVar"><code class="code">Cil.makeTempVar</code></a>. You can also use
 <a href="Cil.html#VALsetMaxId"><code class="code">Cil.setMaxId</code></a> to set it after you
 have added the formals and locals.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTfundec.sbody">sbody</span>&nbsp;: <code class="type"><a href="Cil.html#TYPEblock">block</a></code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>The function body.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTfundec.smaxstmtid">smaxstmtid</span>&nbsp;: <code class="type">int option</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>max id of a (reachable) statement
 in this function, if we have
 computed it. range = 0 ...
 (smaxstmtid-1). This is computed by
 <a href="Cil.html#VALcomputeCFGInfo"><code class="code">Cil.computeCFGInfo</code></a>.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTfundec.sallstmts">sallstmts</span>&nbsp;: <code class="type"><a href="Cil.html#TYPEstmt">stmt</a> list</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>After you call <a href="Cil.html#VALcomputeCFGInfo"><code class="code">Cil.computeCFGInfo</code></a>
 this field is set to contain all
 statements in the function</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
}

<div class="info ">
<div class="info-desc">
<p>Function definitions.</p>
</div>
</div>


<pre><code><span id="TYPEblock"><span class="keyword">type</span> <code class="type"></code>block</span> = {</code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTblock.battrs">battrs</span>&nbsp;: <code class="type"><a href="Cil.html#TYPEattributes">attributes</a></code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>Attributes for the block</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTblock.bstmts">bstmts</span>&nbsp;: <code class="type"><a href="Cil.html#TYPEstmt">stmt</a> list</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>The statements comprising the block</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
}

<div class="info ">
<div class="info-desc">
<p>A block is a sequence of statements with the control falling through from
    one element to the next</p>
</div>
</div>

<p><b>Statements</b>.
    CIL statements are the structural elements that make the CFG. They are
    represented using the type <a href="Cil.html#TYPEstmt"><code class="code">Cil.stmt</code></a>. Every
    statement has a (possibly empty) list of labels. The
    <a href="Cil.html#TYPEstmtkind"><code class="code">Cil.stmtkind</code></a> field of a statement indicates what kind of statement it
    is.</p>

<p>Use <a href="Cil.html#VALmkStmt"><code class="code">Cil.mkStmt</code></a> to make a statement and the fill-in the fields.</p>

<p>CIL also comes with support for control-flow graphs. The <code class="code">sid</code> field in
    <code class="code">stmt</code> can be used to give unique numbers to statements, and the <code class="code">succs</code>
    and <code class="code">preds</code> fields can be used to maintain a list of successors and
    predecessors for every statement. The CFG information is not computed by
    default. Instead you must explicitly use the functions
    <a href="Cil.html#VALprepareCFG"><code class="code">Cil.prepareCFG</code></a> and <a href="Cil.html#VALcomputeCFGInfo"><code class="code">Cil.computeCFGInfo</code></a> to do it.</p>

<pre><code><span id="TYPEstmt"><span class="keyword">type</span> <code class="type"></code>stmt</span> = {</code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTstmt.labels">labels</span>&nbsp;: <code class="type"><a href="Cil.html#TYPElabel">label</a> list</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>Whether the statement starts with some labels, case statements or
 default statements.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTstmt.skind">skind</span>&nbsp;: <code class="type"><a href="Cil.html#TYPEstmtkind">stmtkind</a></code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>The kind of statement</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTstmt.sid">sid</span>&nbsp;: <code class="type">int</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>A number (&gt;= 0) that is unique in a function. Filled in only after
 the CFG is computed.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTstmt.succs">succs</span>&nbsp;: <code class="type"><a href="Cil.html#TYPEstmt">stmt</a> list</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>The successor statements. They can always be computed from the skind
 and the context in which this statement appears. Filled in only after
 the CFG is computed.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTstmt.preds">preds</span>&nbsp;: <code class="type"><a href="Cil.html#TYPEstmt">stmt</a> list</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>The inverse of the succs function.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
}

<div class="info ">
<div class="info-desc">
<p>Statements.</p>
</div>
</div>


<pre><code><span id="TYPElabel"><span class="keyword">type</span> <code class="type"></code>label</span> = </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTlabel.Label"><span class="constructor">Label</span></span> <span class="keyword">of</span> <code class="type">string * <a href="Cil.html#TYPElocation">location</a> * bool</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>A real label. If the bool is "true", the label is from the
 input source program. If the bool is "false", the label was
 created by CIL or some other transformation</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTlabel.Case"><span class="constructor">Case</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEexp">exp</a> * <a href="Cil.html#TYPElocation">location</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>A case statement. This expression
 is lowered into a constant if
 <a href="Cil.html#VALlowerConstants"><code class="code">Cil.lowerConstants</code></a> is set to
 true.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTlabel.CaseRange"><span class="constructor">CaseRange</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEexp">exp</a> * <a href="Cil.html#TYPEexp">exp</a> * <a href="Cil.html#TYPElocation">location</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>A case statement corresponding to a
 range of values (GCC's extension).
 Both expressions are lowered into
 constants if <a href="Cil.html#VALlowerConstants"><code class="code">Cil.lowerConstants</code></a> is
 set to true. If you want to use
 these, you must set
 <a href="Cil.html#VALuseCaseRange"><code class="code">Cil.useCaseRange</code></a>.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTlabel.Default"><span class="constructor">Default</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPElocation">location</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>A default statement</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info ">
<div class="info-desc">
<p>Labels</p>
</div>
</div>


<pre><code><span id="TYPEstmtkind"><span class="keyword">type</span> <code class="type"></code>stmtkind</span> = </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTstmtkind.Instr"><span class="constructor">Instr</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEinstr">instr</a> list</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>A group of instructions that do not contain control flow. Control
 implicitly falls through.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTstmtkind.Return"><span class="constructor">Return</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEexp">exp</a> option * <a href="Cil.html#TYPElocation">location</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>The return statement. This is a leaf in the CFG.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTstmtkind.Goto"><span class="constructor">Goto</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEstmt">stmt</a> ref * <a href="Cil.html#TYPElocation">location</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>A goto statement. Appears from actual goto's in the code or from
 goto's that have been inserted during elaboration. The reference
 points to the statement that is the target of the Goto. This means that
 you have to update the reference whenever you replace the target
 statement. The target statement MUST have at least a label.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTstmtkind.ComputedGoto"><span class="constructor">ComputedGoto</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEexp">exp</a> * <a href="Cil.html#TYPElocation">location</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>A computed goto using GCC's label-as-value extension.  If you want to use
 these, you must set <a href="Cil.html#VALuseComputedGoto"><code class="code">Cil.useComputedGoto</code></a>.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTstmtkind.Break"><span class="constructor">Break</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPElocation">location</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>A break to the end of the nearest enclosing Loop or Switch</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTstmtkind.Continue"><span class="constructor">Continue</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPElocation">location</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>A continue to the start of the nearest enclosing <code class="code">Loop</code></p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTstmtkind.If"><span class="constructor">If</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEexp">exp</a> * <a href="Cil.html#TYPEblock">block</a> * <a href="Cil.html#TYPEblock">block</a> * <a href="Cil.html#TYPElocation">location</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>A conditional. Two successors, the "then" and the "else" branches.
 Both branches fall-through to the successor of the If statement.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTstmtkind.Switch"><span class="constructor">Switch</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEexp">exp</a> * <a href="Cil.html#TYPEblock">block</a> * <a href="Cil.html#TYPEstmt">stmt</a> list * <a href="Cil.html#TYPElocation">location</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>A switch statement. The statements that implement the cases can be
 reached through the provided list. For each such target you can find
 among its labels what cases it implements. The statements that
 implement the cases are somewhere within the provided <code class="code">block</code>.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTstmtkind.Loop"><span class="constructor">Loop</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEblock">block</a> * <a href="Cil.html#TYPElocation">location</a> * <a href="Cil.html#TYPEstmt">stmt</a> option * <a href="Cil.html#TYPEstmt">stmt</a> option</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>A <code class="code">while(1)</code> loop. The termination test is implemented in the body of
 a loop using a <code class="code">Break</code> statement. If prepareCFG has been called,
 the first stmt option will point to the stmt containing the continue
 label for this loop and the second will point to the stmt containing
 the break label for this loop.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTstmtkind.Block"><span class="constructor">Block</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEblock">block</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>Just a block of statements. Use it as a way to keep some block
 attributes local</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTstmtkind.TryFinally"><span class="constructor">TryFinally</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEblock">block</a> * <a href="Cil.html#TYPEblock">block</a> * <a href="Cil.html#TYPElocation">location</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTstmtkind.TryExcept"><span class="constructor">TryExcept</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEblock">block</a> * (<a href="Cil.html#TYPEinstr">instr</a> list * <a href="Cil.html#TYPEexp">exp</a>) * <a href="Cil.html#TYPEblock">block</a> * <a href="Cil.html#TYPElocation">location</a></code></code></td>

</tr></table>

<div class="info ">
<div class="info-desc">
<p>The various kinds of control-flow statements statements</p>
</div>
</div>

<p><b>Instructions</b>.
    An instruction <a href="Cil.html#TYPEinstr"><code class="code">Cil.instr</code></a> is a statement that has no local
    (intraprocedural) control flow. It can be either an assignment,
    function call, or an inline assembly instruction.</p>

<pre><code><span id="TYPEinstr"><span class="keyword">type</span> <code class="type"></code>instr</span> = </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTinstr.Set"><span class="constructor">Set</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPElval">lval</a> * <a href="Cil.html#TYPEexp">exp</a> * <a href="Cil.html#TYPElocation">location</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>An assignment. The type of the expression is guaranteed to be the same
 with that of the lvalue</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTinstr.Call"><span class="constructor">Call</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPElval">lval</a> option * <a href="Cil.html#TYPEexp">exp</a> * <a href="Cil.html#TYPEexp">exp</a> list * <a href="Cil.html#TYPElocation">location</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>A function call with the (optional) result placed in an lval. It is
 possible that the returned type of the function is not identical to
 that of the lvalue. In that case a cast is printed. The type of the
 actual arguments are identical to those of the declared formals. The
 number of arguments is the same as that of the declared formals, except
 for vararg functions. This construct is also used to encode a call to
 "__builtin_va_arg". In this case the second argument (which should be a
 type T) is encoded SizeOf(T)</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTinstr.Asm"><span class="constructor">Asm</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEattributes">attributes</a> * string list * (string option * string * <a href="Cil.html#TYPElval">lval</a>) list<br>        * (string option * string * <a href="Cil.html#TYPEexp">exp</a>) list * string list * <a href="Cil.html#TYPElocation">location</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>There are for storing inline assembly. They follow the GCC
 specification:</p>
<pre class="verbatim">  asm [volatile] ("...template..." "..template.."
                  : "c1" (o1), "c2" (o2), ..., "cN" (oN)
                  : "d1" (i1), "d2" (i2), ..., "dM" (iM)
                  : "r1", "r2", ..., "nL" );
</pre>
<p>where the parts are</p>

<ul>
<li><code class="code">volatile</code> (optional): when present, the assembler instruction
      cannot be removed, moved, or otherwise optimized</li>
<li>template: a sequence of strings, with %0, %1, %2, etc. in the string to
      refer to the input and output expressions. I think they're numbered
      consecutively, but the docs don't specify. Each string is printed on
      a separate line. This is the only part that is present for MSVC inline
      assembly.</li>
<li>"ci" (oi): pairs of constraint-string and output-lval; the
      constraint specifies that the register used must have some
      property, like being a floating-point register; the constraint
      string for outputs also has "=" to indicate it is written, or
      "+" to indicate it is both read and written; 'oi' is the
      name of a C lvalue (probably a variable name) to be used as
      the output destination</li>
<li>"dj" (ij): pairs of constraint and input expression; the constraint
      is similar to the "ci"s.  the 'ij' is an arbitrary C expression
      to be loaded into the corresponding register</li>
<li>"rk": registers to be regarded as "clobbered" by the instruction;
      "memory" may be specified for arbitrary memory effects</li>
</ul>
<p>an example (from gcc manual):</p>
<pre class="verbatim">  asm volatile ("movc3 %0,%1,%2"
                : /* no outputs */
                : "g" (from), "g" (to), "g" (count)
                : "r0", "r1", "r2", "r3", "r4", "r5");
</pre>
<p>Starting with gcc 3.1, the operands may have names:</p>

<pre class="verbatim">  asm volatile ("movc3 %[in0],%1,%2"
                : /* no outputs */
                : [in0] "g" (from), "g" (to), "g" (count)
                : "r0", "r1", "r2", "r3", "r4", "r5");
</pre></div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info ">
<div class="info-desc">
<p>Instructions.</p>
</div>
</div>


<pre><code><span id="TYPElocation"><span class="keyword">type</span> <code class="type"></code>location</span> = {</code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTlocation.line">line</span>&nbsp;: <code class="type">int</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>The line number. -1 means "do not know"</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTlocation.file">file</span>&nbsp;: <code class="type">string</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>The name of the source file</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTlocation.byte">byte</span>&nbsp;: <code class="type">int</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>The byte position in the source file</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
}

<div class="info ">
<div class="info-desc">
<p>Describes a location in a source file.</p>
</div>
</div>


<pre><code><span id="TYPEtypsig"><span class="keyword">type</span> <code class="type"></code>typsig</span> = </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTtypsig.TSArray"><span class="constructor">TSArray</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEtypsig">typsig</a> * int64 option * <a href="Cil.html#TYPEattribute">attribute</a> list</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTtypsig.TSPtr"><span class="constructor">TSPtr</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEtypsig">typsig</a> * <a href="Cil.html#TYPEattribute">attribute</a> list</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTtypsig.TSComp"><span class="constructor">TSComp</span></span> <span class="keyword">of</span> <code class="type">bool * string * <a href="Cil.html#TYPEattribute">attribute</a> list</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTtypsig.TSFun"><span class="constructor">TSFun</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEtypsig">typsig</a> * <a href="Cil.html#TYPEtypsig">typsig</a> list option * bool * <a href="Cil.html#TYPEattribute">attribute</a> list</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTtypsig.TSEnum"><span class="constructor">TSEnum</span></span> <span class="keyword">of</span> <code class="type">string * <a href="Cil.html#TYPEattribute">attribute</a> list</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTtypsig.TSBase"><span class="constructor">TSBase</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEtyp">typ</a></code></code></td>

</tr></table>

<div class="info ">
<div class="info-desc">
<p>Type signatures. Two types are identical iff they have identical
 signatures. These contain the same information as types but canonicalized.
 For example, two function types that are identical except for the name of
 the formal arguments are given the same signature. Also, <code class="code">TNamed</code>
 constructors are unrolled.</p>
</div>
</div>

<p><b>Lowering Options</b></p>

<pre><span id="VALlowerConstants"><span class="keyword">val</span> lowerConstants</span> : <code class="type">bool ref</code></pre><div class="info ">
<div class="info-desc">
<p>Do lower constants (default true)</p>
</div>
</div>

<pre><span id="VALinsertImplicitCasts"><span class="keyword">val</span> insertImplicitCasts</span> : <code class="type">bool ref</code></pre><div class="info ">
<div class="info-desc">
<p>Do insert implicit casts (default true)</p>
</div>
</div>

<pre><span id="VALcompareLoc"><span class="keyword">val</span> compareLoc</span> : <code class="type"><a href="Cil.html#TYPElocation">location</a> -> <a href="Cil.html#TYPElocation">location</a> -> int</code></pre><div class="info ">
<div class="info-desc">
<p>Comparison function for locations.
* Compares first by filename, then line, then byte</p>
</div>
</div>
<p><b>Values for manipulating globals</b></p>

<pre><span id="VALemptyFunction"><span class="keyword">val</span> emptyFunction</span> : <code class="type">string -> <a href="Cil.html#TYPEfundec">fundec</a></code></pre><div class="info ">
<div class="info-desc">
<p>Make an empty function</p>
</div>
</div>

<pre><span id="VALsetFormals"><span class="keyword">val</span> setFormals</span> : <code class="type"><a href="Cil.html#TYPEfundec">fundec</a> -> <a href="Cil.html#TYPEvarinfo">varinfo</a> list -> unit</code></pre><div class="info ">
<div class="info-desc">
<p>Update the formals of a <code class="code">fundec</code> and make sure that the function type
    has the same information. Will copy the name as well into the type.</p>
</div>
</div>

<pre><span id="VALsetFunctionType"><span class="keyword">val</span> setFunctionType</span> : <code class="type"><a href="Cil.html#TYPEfundec">fundec</a> -> <a href="Cil.html#TYPEtyp">typ</a> -> unit</code></pre><div class="info ">
<div class="info-desc">
<p>Set the types of arguments and results as given by the function type
 passed as the second argument. Will not copy the names from the function
 type to the formals</p>
</div>
</div>

<pre><span id="VALsetFunctionTypeMakeFormals"><span class="keyword">val</span> setFunctionTypeMakeFormals</span> : <code class="type"><a href="Cil.html#TYPEfundec">fundec</a> -> <a href="Cil.html#TYPEtyp">typ</a> -> unit</code></pre><div class="info ">
<div class="info-desc">
<p>Set the type of the function and make formal arguments for them</p>
</div>
</div>

<pre><span id="VALsetMaxId"><span class="keyword">val</span> setMaxId</span> : <code class="type"><a href="Cil.html#TYPEfundec">fundec</a> -> unit</code></pre><div class="info ">
<div class="info-desc">
<p>Update the smaxid after you have populated with locals and formals
 (unless you constructed those using <a href="Cil.html#VALmakeLocalVar"><code class="code">Cil.makeLocalVar</code></a> or
 <a href="Cil.html#VALmakeTempVar"><code class="code">Cil.makeTempVar</code></a>.</p>
</div>
</div>

<pre><span id="VALdummyFunDec"><span class="keyword">val</span> dummyFunDec</span> : <code class="type"><a href="Cil.html#TYPEfundec">fundec</a></code></pre><div class="info ">
<div class="info-desc">
<p>A dummy function declaration handy when you need one as a placeholder. It
 contains inside a dummy varinfo.</p>
</div>
</div>

<pre><span id="VALdummyFile"><span class="keyword">val</span> dummyFile</span> : <code class="type"><a href="Cil.html#TYPEfile">file</a></code></pre><div class="info ">
<div class="info-desc">
<p>A dummy file</p>
</div>
</div>

<pre><span id="VALsaveBinaryFile"><span class="keyword">val</span> saveBinaryFile</span> : <code class="type"><a href="Cil.html#TYPEfile">file</a> -> string -> unit</code></pre><div class="info ">
<div class="info-desc">
<p>Write a <a href="Cil.html#TYPEfile"><code class="code">Cil.file</code></a> in binary form to the filesystem. The file can be
 read back in later using <a href="Cil.html#VALloadBinaryFile"><code class="code">Cil.loadBinaryFile</code></a>, possibly saving parsing
 time. The second argument is the name of the file that should be
 created.</p>
</div>
</div>

<pre><span id="VALsaveBinaryFileChannel"><span class="keyword">val</span> saveBinaryFileChannel</span> : <code class="type"><a href="Cil.html#TYPEfile">file</a> -> out_channel -> unit</code></pre><div class="info ">
<div class="info-desc">
<p>Write a <a href="Cil.html#TYPEfile"><code class="code">Cil.file</code></a> in binary form to the filesystem. The file can be
 read back in later using <a href="Cil.html#VALloadBinaryFile"><code class="code">Cil.loadBinaryFile</code></a>, possibly saving parsing
 time. Does not close the channel.</p>
</div>
</div>

<pre><span id="VALloadBinaryFile"><span class="keyword">val</span> loadBinaryFile</span> : <code class="type">string -> <a href="Cil.html#TYPEfile">file</a></code></pre><div class="info ">
<div class="info-desc">
<p>Read a <a href="Cil.html#TYPEfile"><code class="code">Cil.file</code></a> in binary form from the filesystem. The first
 argument is the name of a file previously created by
 <a href="Cil.html#VALsaveBinaryFile"><code class="code">Cil.saveBinaryFile</code></a>. Because this also reads some global state,
 this should be called before any other CIL code is parsed or generated.</p>
</div>
</div>

<pre><span id="VALgetGlobInit"><span class="keyword">val</span> getGlobInit</span> : <code class="type">?main_name:string -> <a href="Cil.html#TYPEfile">file</a> -> <a href="Cil.html#TYPEfundec">fundec</a></code></pre><div class="info ">
<div class="info-desc">
<p>Get the global initializer and create one if it does not already exist.
 When it creates a global initializer it attempts to place a call to it in
 the main function named by the optional argument (default "main")</p>
</div>
</div>

<pre><span id="VALiterGlobals"><span class="keyword">val</span> iterGlobals</span> : <code class="type"><a href="Cil.html#TYPEfile">file</a> -> (<a href="Cil.html#TYPEglobal">global</a> -> unit) -> unit</code></pre><div class="info ">
<div class="info-desc">
<p>Iterate over all globals, including the global initializer</p>
</div>
</div>

<pre><span id="VALfoldGlobals"><span class="keyword">val</span> foldGlobals</span> : <code class="type"><a href="Cil.html#TYPEfile">file</a> -> ('a -> <a href="Cil.html#TYPEglobal">global</a> -> 'a) -> 'a -> 'a</code></pre><div class="info ">
<div class="info-desc">
<p>Fold over all globals, including the global initializer</p>
</div>
</div>

<pre><span id="VALmapGlobals"><span class="keyword">val</span> mapGlobals</span> : <code class="type"><a href="Cil.html#TYPEfile">file</a> -> (<a href="Cil.html#TYPEglobal">global</a> -> <a href="Cil.html#TYPEglobal">global</a>) -> unit</code></pre><div class="info ">
<div class="info-desc">
<p>Map over all globals, including the global initializer and change things
    in place</p>
</div>
</div>

<pre><span id="VALfindOrCreateFunc"><span class="keyword">val</span> findOrCreateFunc</span> : <code class="type"><a href="Cil.html#TYPEfile">file</a> -> string -> <a href="Cil.html#TYPEtyp">typ</a> -> <a href="Cil.html#TYPEvarinfo">varinfo</a></code></pre><div class="info ">
<div class="info-desc">
<p>Find a function or function prototype with the given name in the file.
 If it does not exist, create a prototype with the given type, and return
 the new varinfo.  This is useful when you need to call a libc function
 whose prototype may or may not already exist in the file.</p>

<p>Because the new prototype is added to the start of the file, you shouldn't
 refer to any struct or union types in the function type.</p>
</div>
</div>

<pre><span id="VALnew_sid"><span class="keyword">val</span> new_sid</span> : <code class="type">unit -> int</code></pre>
<pre><span id="VALprepareCFG"><span class="keyword">val</span> prepareCFG</span> : <code class="type"><a href="Cil.html#TYPEfundec">fundec</a> -> unit</code></pre><div class="info ">
<div class="info-desc">
<p>Prepare a function for CFG information computation by
 <a href="Cil.html#VALcomputeCFGInfo"><code class="code">Cil.computeCFGInfo</code></a>. This function converts all <code class="code">Break</code>, <code class="code">Switch</code>,
 <code class="code">Default</code> and <code class="code">Continue</code> <a href="Cil.html#TYPEstmtkind"><code class="code">Cil.stmtkind</code></a>s and <a href="Cil.html#TYPElabel"><code class="code">Cil.label</code></a>s into <code class="code">If</code>s
 and <code class="code">Goto</code>s, giving the function body a very CFG-like character. This
 function modifies its argument in place.</p>
</div>
</div>

<pre><span id="VALcomputeCFGInfo"><span class="keyword">val</span> computeCFGInfo</span> : <code class="type"><a href="Cil.html#TYPEfundec">fundec</a> -> bool -> unit</code></pre><div class="info ">
<div class="info-desc">
<p>Compute the CFG information for all statements in a fundec and return a
 list of the statements. The input fundec cannot have <code class="code">Break</code>, <code class="code">Switch</code>,
 <code class="code">Default</code>, or <code class="code">Continue</code> <a href="Cil.html#TYPEstmtkind"><code class="code">Cil.stmtkind</code></a>s or <a href="Cil.html#TYPElabel"><code class="code">Cil.label</code></a>s. Use
 <a href="Cil.html#VALprepareCFG"><code class="code">Cil.prepareCFG</code></a> to transform them away.  The second argument should
 be <code class="code">true</code> if you wish a global statement number, <code class="code">false</code> if you wish a
 local (per-function) statement numbering. The list of statements is set
 in the sallstmts field of a fundec.</p>

<p>NOTE: unless you want the simpler control-flow graph provided by
 prepareCFG, or you need the function's smaxstmtid and sallstmt fields
 filled in, we recommend you use <a href="Cfg.html#VALcomputeFileCFG"><code class="code">Cfg.computeFileCFG</code></a> instead of this
 function to compute control-flow information.
 <a href="Cfg.html#VALcomputeFileCFG"><code class="code">Cfg.computeFileCFG</code></a> is newer and will handle switch, break, and
 continue correctly.</p>
</div>
</div>

<pre><span id="VALcopyFunction"><span class="keyword">val</span> copyFunction</span> : <code class="type"><a href="Cil.html#TYPEfundec">fundec</a> -> string -> <a href="Cil.html#TYPEfundec">fundec</a></code></pre><div class="info ">
<div class="info-desc">
<p>Create a deep copy of a function. There should be no sharing between the
 copy and the original function</p>
</div>
</div>

<pre><span id="VALpushGlobal"><span class="keyword">val</span> pushGlobal</span> : <code class="type"><a href="Cil.html#TYPEglobal">global</a> -><br>       types:<a href="Cil.html#TYPEglobal">global</a> list ref -><br>       variables:<a href="Cil.html#TYPEglobal">global</a> list ref -> unit</code></pre><div class="info ">
<div class="info-desc">
<p>CIL keeps the types at the beginning of the file and the variables at the
 end of the file. This function will take a global and add it to the
 corresponding stack. Its operation is actually more complicated because if
 the global declares a type that contains references to variables (e.g. in
 sizeof in an array length) then it will also add declarations for the
 variables to the types stack</p>
</div>
</div>

<pre><span id="VALinvalidStmt"><span class="keyword">val</span> invalidStmt</span> : <code class="type"><a href="Cil.html#TYPEstmt">stmt</a></code></pre><div class="info ">
<div class="info-desc">
<p>An empty statement. Used in pretty printing</p>
</div>
</div>

<pre><span id="VALbuiltinFunctions"><span class="keyword">val</span> builtinFunctions</span> : <code class="type">(string, <a href="Cil.html#TYPEtyp">typ</a> * <a href="Cil.html#TYPEtyp">typ</a> list * bool) Hashtbl.t</code></pre><div class="info ">
<div class="info-desc">
<p>A list of the built-in functions for the current compiler (GCC or
 MSVC, depending on <code class="code">!msvcMode</code>).  Maps the name to the
 result and argument types, and whether it is vararg.
 Initialized by <a href="Cil.html#VALinitCIL"><code class="code">Cil.initCIL</code></a></p>

<p>This map replaces <code class="code">gccBuiltins</code> and <code class="code">msvcBuiltins</code> in previous
 versions of CIL.</p>
</div>
</div>

<pre><span id="VALbuiltinLoc"><span class="keyword">val</span> builtinLoc</span> : <code class="type"><a href="Cil.html#TYPElocation">location</a></code></pre><div class="info ">
<div class="info-desc">
<p>This is used as the location of the prototypes of builtin functions.</p>
</div>
</div>
<p><b>Values for manipulating initializers</b></p>

<pre><span id="VALmakeZeroInit"><span class="keyword">val</span> makeZeroInit</span> : <code class="type"><a href="Cil.html#TYPEtyp">typ</a> -> <a href="Cil.html#TYPEinit">init</a></code></pre><div class="info ">
<div class="info-desc">
<p>Make a initializer for zero-ing a data type</p>
</div>
</div>

<pre><span id="VALfoldLeftCompound"><span class="keyword">val</span> foldLeftCompound</span> : <code class="type">implicit:bool -><br>       doinit:(<a href="Cil.html#TYPEoffset">offset</a> -> <a href="Cil.html#TYPEinit">init</a> -> <a href="Cil.html#TYPEtyp">typ</a> -> 'a -> 'a) -><br>       ct:<a href="Cil.html#TYPEtyp">typ</a> -> initl:(<a href="Cil.html#TYPEoffset">offset</a> * <a href="Cil.html#TYPEinit">init</a>) list -> acc:'a -> 'a</code></pre><div class="info ">
<div class="info-desc">
<p>Fold over the list of initializers in a Compound (not also the nested
 ones). <code class="code">doinit</code> is called on every present initializer, even if it is of
 compound type. The parameters of <code class="code">doinit</code> are: the offset in the compound
 (this is <code class="code">Field(f,NoOffset)</code> or <code class="code">Index(i,NoOffset)</code>), the initializer
 value, expected type of the initializer value, accumulator. In the case of
 arrays there might be missing zero-initializers at the end of the list.
 These are scanned only if <code class="code">implicit</code> is true. This is much like
 <code class="code">List.fold_left</code> except we also pass the type of the initializer.</p>

<p>This is a good way to use it to scan even nested initializers :</p>
<pre class="verbatim">  let rec myInit (lv: lval) (i: init) (acc: 'a) : 'a =
      match i with
        SingleInit e -&gt; ... do something with lv and e and acc ...
      | CompoundInit (ct, initl) -&gt;
         foldLeftCompound ~implicit:false
             ~doinit:(fun off' i' t' acc -&gt;
                        myInit (addOffsetLval lv off') i' acc)
             ~ct:ct
             ~initl:initl
             ~acc:acc</pre></div>
</div>
<p><b>Values for manipulating types</b></p>

<pre><span id="VALvoidType"><span class="keyword">val</span> voidType</span> : <code class="type"><a href="Cil.html#TYPEtyp">typ</a></code></pre><div class="info ">
<div class="info-desc">
<p>void</p>
</div>
</div>

<pre><span id="VALisVoidType"><span class="keyword">val</span> isVoidType</span> : <code class="type"><a href="Cil.html#TYPEtyp">typ</a> -> bool</code></pre><div class="info ">
<div class="info-desc">
<p>is the given type "void"?</p>
</div>
</div>

<pre><span id="VALisVoidPtrType"><span class="keyword">val</span> isVoidPtrType</span> : <code class="type"><a href="Cil.html#TYPEtyp">typ</a> -> bool</code></pre><div class="info ">
<div class="info-desc">
<p>is the given type "void *"?</p>
</div>
</div>

<pre><span id="VALintType"><span class="keyword">val</span> intType</span> : <code class="type"><a href="Cil.html#TYPEtyp">typ</a></code></pre><div class="info ">
<div class="info-desc">
<p>int</p>
</div>
</div>

<pre><span id="VALuintType"><span class="keyword">val</span> uintType</span> : <code class="type"><a href="Cil.html#TYPEtyp">typ</a></code></pre><div class="info ">
<div class="info-desc">
<p>unsigned int</p>
</div>
</div>

<pre><span id="VALlongType"><span class="keyword">val</span> longType</span> : <code class="type"><a href="Cil.html#TYPEtyp">typ</a></code></pre><div class="info ">
<div class="info-desc">
<p>long</p>
</div>
</div>

<pre><span id="VALulongType"><span class="keyword">val</span> ulongType</span> : <code class="type"><a href="Cil.html#TYPEtyp">typ</a></code></pre><div class="info ">
<div class="info-desc">
<p>unsigned long</p>
</div>
</div>

<pre><span id="VALcharType"><span class="keyword">val</span> charType</span> : <code class="type"><a href="Cil.html#TYPEtyp">typ</a></code></pre><div class="info ">
<div class="info-desc">
<p>char</p>
</div>
</div>

<pre><span id="VALcharPtrType"><span class="keyword">val</span> charPtrType</span> : <code class="type"><a href="Cil.html#TYPEtyp">typ</a></code></pre><div class="info ">
<div class="info-desc">
<p>char *</p>
</div>
</div>

<pre><span id="VALwcharKind"><span class="keyword">val</span> wcharKind</span> : <code class="type"><a href="Cil.html#TYPEikind">ikind</a> ref</code></pre><div class="info ">
<div class="info-desc">
<p>wchar_t (depends on architecture) and is set when you call
 <a href="Cil.html#VALinitCIL"><code class="code">Cil.initCIL</code></a>.</p>
</div>
</div>

<pre><span id="VALwcharType"><span class="keyword">val</span> wcharType</span> : <code class="type"><a href="Cil.html#TYPEtyp">typ</a> ref</code></pre>
<pre><span id="VALcharConstPtrType"><span class="keyword">val</span> charConstPtrType</span> : <code class="type"><a href="Cil.html#TYPEtyp">typ</a></code></pre><div class="info ">
<div class="info-desc">
<p>char const *</p>
</div>
</div>

<pre><span id="VALvoidPtrType"><span class="keyword">val</span> voidPtrType</span> : <code class="type"><a href="Cil.html#TYPEtyp">typ</a></code></pre><div class="info ">
<div class="info-desc">
<p>void *</p>
</div>
</div>

<pre><span id="VALintPtrType"><span class="keyword">val</span> intPtrType</span> : <code class="type"><a href="Cil.html#TYPEtyp">typ</a></code></pre><div class="info ">
<div class="info-desc">
<p>int *</p>
</div>
</div>

<pre><span id="VALuintPtrType"><span class="keyword">val</span> uintPtrType</span> : <code class="type"><a href="Cil.html#TYPEtyp">typ</a></code></pre><div class="info ">
<div class="info-desc">
<p>unsigned int *</p>
</div>
</div>

<pre><span id="VALdoubleType"><span class="keyword">val</span> doubleType</span> : <code class="type"><a href="Cil.html#TYPEtyp">typ</a></code></pre><div class="info ">
<div class="info-desc">
<p>double</p>
</div>
</div>

<pre><span id="VALupointType"><span class="keyword">val</span> upointType</span> : <code class="type"><a href="Cil.html#TYPEtyp">typ</a> ref</code></pre><div class="info ">
<div class="info-desc">
<p>An unsigned integer type that fits pointers. Depends on <a href="Cil.html#VALmsvcMode"><code class="code">Cil.msvcMode</code></a>
  and is set when you call <a href="Cil.html#VALinitCIL"><code class="code">Cil.initCIL</code></a>.</p>
</div>
</div>

<pre><span id="VALptrdiffType"><span class="keyword">val</span> ptrdiffType</span> : <code class="type"><a href="Cil.html#TYPEtyp">typ</a> ref</code></pre><div class="info ">
<div class="info-desc">
<p>An signed integer type that fits pointer difference. Depends on
  <a href="Cil.html#VALmsvcMode"><code class="code">Cil.msvcMode</code></a> and is set when you call <a href="Cil.html#VALinitCIL"><code class="code">Cil.initCIL</code></a>.</p>
</div>
</div>

<pre><span id="VALtypeOfSizeOf"><span class="keyword">val</span> typeOfSizeOf</span> : <code class="type"><a href="Cil.html#TYPEtyp">typ</a> ref</code></pre><div class="info ">
<div class="info-desc">
<p>An unsigned integer type that is the type of sizeof. Depends on
 <a href="Cil.html#VALmsvcMode"><code class="code">Cil.msvcMode</code></a> and is set when you call <a href="Cil.html#VALinitCIL"><code class="code">Cil.initCIL</code></a>.</p>
</div>
</div>

<pre><span id="VALkindOfSizeOf"><span class="keyword">val</span> kindOfSizeOf</span> : <code class="type"><a href="Cil.html#TYPEikind">ikind</a> ref</code></pre><div class="info ">
<div class="info-desc">
<p>The integer kind of <a href="Cil.html#VALtypeOfSizeOf"><code class="code">Cil.typeOfSizeOf</code></a>.
  Set when you call <a href="Cil.html#VALinitCIL"><code class="code">Cil.initCIL</code></a>.</p>
</div>
</div>

<pre><span id="VALisSigned"><span class="keyword">val</span> isSigned</span> : <code class="type"><a href="Cil.html#TYPEikind">ikind</a> -> bool</code></pre><div class="info ">
<div class="info-desc">
<p>Returns true if and only if the given integer type is signed.</p>
</div>
</div>

<pre><span id="VALmkCompInfo"><span class="keyword">val</span> mkCompInfo</span> : <code class="type">bool -><br>       string -><br>       (<a href="Cil.html#TYPEcompinfo">compinfo</a> -><br>        (string * <a href="Cil.html#TYPEtyp">typ</a> * int option * <a href="Cil.html#TYPEattributes">attributes</a> * <a href="Cil.html#TYPElocation">location</a>) list) -><br>       <a href="Cil.html#TYPEattributes">attributes</a> -> <a href="Cil.html#TYPEcompinfo">compinfo</a></code></pre><div class="info ">
<div class="info-desc">
<p>Creates a a (potentially recursive) composite type. The arguments are:
 (1) a boolean indicating whether it is a struct or a union, (2) the name
 (always non-empty), (3) a function that when given a representation of the
 structure type constructs the type of the fields recursive type (the first
 argument is only useful when some fields need to refer to the type of the
 structure itself), and (4) a list of attributes to be associated with the
 composite type. The resulting compinfo has the field "cdefined" only if
 the list of fields is non-empty.</p>
</div>
</div>

<pre><span id="VALcopyCompInfo"><span class="keyword">val</span> copyCompInfo</span> : <code class="type"><a href="Cil.html#TYPEcompinfo">compinfo</a> -> string -> <a href="Cil.html#TYPEcompinfo">compinfo</a></code></pre><div class="info ">
<div class="info-desc">
<p>Makes a shallow copy of a <a href="Cil.html#TYPEcompinfo"><code class="code">Cil.compinfo</code></a> changing the name and the key.</p>
</div>
</div>

<pre><span id="VALmissingFieldName"><span class="keyword">val</span> missingFieldName</span> : <code class="type">string</code></pre><div class="info ">
<div class="info-desc">
<p>This is a constant used as the name of an unnamed bitfield. These fields
    do not participate in initialization and their name is not printed.</p>
</div>
</div>

<pre><span id="VALcompFullName"><span class="keyword">val</span> compFullName</span> : <code class="type"><a href="Cil.html#TYPEcompinfo">compinfo</a> -> string</code></pre><div class="info ">
<div class="info-desc">
<p>Get the full name of a comp</p>
</div>
</div>

<pre><span id="VALisCompleteType"><span class="keyword">val</span> isCompleteType</span> : <code class="type"><a href="Cil.html#TYPEtyp">typ</a> -> bool</code></pre><div class="info ">
<div class="info-desc">
<p>Returns true if this is a complete type.
    This means that sizeof(t) makes sense.
    Incomplete types are not yet defined
    structures and empty arrays.</p>
</div>
</div>

<pre><span id="VALunrollType"><span class="keyword">val</span> unrollType</span> : <code class="type"><a href="Cil.html#TYPEtyp">typ</a> -> <a href="Cil.html#TYPEtyp">typ</a></code></pre><div class="info ">
<div class="info-desc">
<p>Unroll a type until it exposes a non
 <code class="code">TNamed</code>. Will collect all attributes appearing in <code class="code">TNamed</code>!!!</p>
</div>
</div>

<pre><span id="VALunrollTypeDeep"><span class="keyword">val</span> unrollTypeDeep</span> : <code class="type"><a href="Cil.html#TYPEtyp">typ</a> -> <a href="Cil.html#TYPEtyp">typ</a></code></pre><div class="info ">
<div class="info-desc">
<p>Unroll all the TNamed in a type (even under type constructors such as
 <code class="code">TPtr</code>, <code class="code">TFun</code> or <code class="code">TArray</code>. Does not unroll the types of fields in <code class="code">TComp</code>
 types. Will collect all attributes</p>
</div>
</div>

<pre><span id="VALseparateStorageModifiers"><span class="keyword">val</span> separateStorageModifiers</span> : <code class="type"><a href="Cil.html#TYPEattribute">attribute</a> list -> <a href="Cil.html#TYPEattribute">attribute</a> list * <a href="Cil.html#TYPEattribute">attribute</a> list</code></pre><div class="info ">
<div class="info-desc">
<p>Separate out the storage-modifier name attributes</p>
</div>
</div>

<pre><span id="VALisIntegralType"><span class="keyword">val</span> isIntegralType</span> : <code class="type"><a href="Cil.html#TYPEtyp">typ</a> -> bool</code></pre><div class="info ">
<div class="info-desc">
<p>True if the argument is an integral type (i.e. integer or enum)</p>
</div>
</div>

<pre><span id="VALisArithmeticType"><span class="keyword">val</span> isArithmeticType</span> : <code class="type"><a href="Cil.html#TYPEtyp">typ</a> -> bool</code></pre><div class="info ">
<div class="info-desc">
<p>True if the argument is an arithmetic type (i.e. integer, enum or
    floating point</p>
</div>
</div>

<pre><span id="VALisPointerType"><span class="keyword">val</span> isPointerType</span> : <code class="type"><a href="Cil.html#TYPEtyp">typ</a> -> bool</code></pre><div class="info ">
<div class="info-desc">
<p>True if the argument is a pointer type</p>
</div>
</div>

<pre><span id="VALisScalarType"><span class="keyword">val</span> isScalarType</span> : <code class="type"><a href="Cil.html#TYPEtyp">typ</a> -> bool</code></pre><div class="info ">
<div class="info-desc">
<p>True if the argument is a scalar type</p>
</div>
</div>

<pre><span id="VALisFunctionType"><span class="keyword">val</span> isFunctionType</span> : <code class="type"><a href="Cil.html#TYPEtyp">typ</a> -> bool</code></pre><div class="info ">
<div class="info-desc">
<p>True if the argument is a function type</p>
</div>
</div>

<pre><span id="VALargsToList"><span class="keyword">val</span> argsToList</span> : <code class="type">(string * <a href="Cil.html#TYPEtyp">typ</a> * <a href="Cil.html#TYPEattributes">attributes</a>) list option -><br>       (string * <a href="Cil.html#TYPEtyp">typ</a> * <a href="Cil.html#TYPEattributes">attributes</a>) list</code></pre><div class="info ">
<div class="info-desc">
<p>Obtain the argument list ([] if None)</p>
</div>
</div>

<pre><span id="VALisArrayType"><span class="keyword">val</span> isArrayType</span> : <code class="type"><a href="Cil.html#TYPEtyp">typ</a> -> bool</code></pre><div class="info ">
<div class="info-desc">
<p>True if the argument is an array type</p>
</div>
</div>

<pre><span id="EXCEPTIONLenOfArray"><span class="keyword">exception</span> LenOfArray</span></pre>
<div class="info ">
<div class="info-desc">
<p>Raised when <a href="Cil.html#VALlenOfArray"><code class="code">Cil.lenOfArray</code></a> fails either because the length is <code class="code">None</code>
 or because it is a non-constant expression</p>
</div>
</div>

<pre><span id="VALlenOfArray"><span class="keyword">val</span> lenOfArray</span> : <code class="type"><a href="Cil.html#TYPEexp">exp</a> option -> int</code></pre><div class="info ">
<div class="info-desc">
<p>Call to compute the array length as present in the array type, to an
 integer. Raises <a href="Cil.html#EXCEPTIONLenOfArray"><code class="code">Cil.LenOfArray</code></a> if not able to compute the length, such
 as when there is no length or the length is not a constant.</p>
</div>
</div>

<pre><span id="VALgetCompField"><span class="keyword">val</span> getCompField</span> : <code class="type"><a href="Cil.html#TYPEcompinfo">compinfo</a> -> string -> <a href="Cil.html#TYPEfieldinfo">fieldinfo</a></code></pre><div class="info ">
<div class="info-desc">
<p>Return a named fieldinfo in compinfo, or raise Not_found</p>
</div>
</div>

<pre><code><span id="TYPEexistsAction"><span class="keyword">type</span> <code class="type"></code>existsAction</span> = </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTexistsAction.ExistsTrue"><span class="constructor">ExistsTrue</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>We have found it</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTexistsAction.ExistsFalse"><span class="constructor">ExistsFalse</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>Stop processing this branch</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTexistsAction.ExistsMaybe"><span class="constructor">ExistsMaybe</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>This node is not what we are
 looking for but maybe its
 successors are</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info ">
<div class="info-desc">
<p>A datatype to be used in conjunction with <code class="code">existsType</code></p>
</div>
</div>


<pre><span id="VALexistsType"><span class="keyword">val</span> existsType</span> : <code class="type">(<a href="Cil.html#TYPEtyp">typ</a> -> <a href="Cil.html#TYPEexistsAction">existsAction</a>) -> <a href="Cil.html#TYPEtyp">typ</a> -> bool</code></pre><div class="info ">
<div class="info-desc">
<p>Scans a type by applying the function on all elements.
    When the function returns ExistsTrue, the scan stops with
    true. When the function returns ExistsFalse then the current branch is not
    scanned anymore. Care is taken to
    apply the function only once on each composite type, thus avoiding
    circularity. When the function returns ExistsMaybe then the types that
    construct the current type are scanned (e.g. the base type for TPtr and
    TArray, the type of fields for a TComp, etc).</p>
</div>
</div>

<pre><span id="VALsplitFunctionType"><span class="keyword">val</span> splitFunctionType</span> : <code class="type"><a href="Cil.html#TYPEtyp">typ</a> -><br>       <a href="Cil.html#TYPEtyp">typ</a> * (string * <a href="Cil.html#TYPEtyp">typ</a> * <a href="Cil.html#TYPEattributes">attributes</a>) list option * bool *<br>       <a href="Cil.html#TYPEattributes">attributes</a></code></pre><div class="info ">
<div class="info-desc">
<p>Given a function type split it into return type,
 arguments, is_vararg and attributes. An error is raised if the type is not
 a function type</p>
</div>
</div>

<pre><span id="VALsplitFunctionTypeVI"><span class="keyword">val</span> splitFunctionTypeVI</span> : <code class="type"><a href="Cil.html#TYPEvarinfo">varinfo</a> -><br>       <a href="Cil.html#TYPEtyp">typ</a> * (string * <a href="Cil.html#TYPEtyp">typ</a> * <a href="Cil.html#TYPEattributes">attributes</a>) list option * bool *<br>       <a href="Cil.html#TYPEattributes">attributes</a></code></pre><div class="info ">
<div class="info-desc">
<p>Same as <a href="Cil.html#VALsplitFunctionType"><code class="code">Cil.splitFunctionType</code></a> but takes a varinfo. Prints a nicer
 error message if the varinfo is not for a function</p>
</div>
</div>
<p><b>Type signatures</b></p>
<p>Type signatures. Two types are identical iff they have identical
 signatures. These contain the same information as types but canonicalized.
 For example, two function types that are identical except for the name of
 the formal arguments are given the same signature. Also, <code class="code">TNamed</code>
 constructors are unrolled.</p>

<pre><span id="VALd_typsig"><span class="keyword">val</span> d_typsig</span> : <code class="type">unit -> <a href="Cil.html#TYPEtypsig">typsig</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info ">
<div class="info-desc">
<p>Print a type signature</p>
</div>
</div>

<pre><span id="VALtypeSig"><span class="keyword">val</span> typeSig</span> : <code class="type"><a href="Cil.html#TYPEtyp">typ</a> -> <a href="Cil.html#TYPEtypsig">typsig</a></code></pre><div class="info ">
<div class="info-desc">
<p>Compute a type signature</p>
</div>
</div>

<pre><span id="VALtypeSigWithAttrs"><span class="keyword">val</span> typeSigWithAttrs</span> : <code class="type">?ignoreSign:bool -><br>       (<a href="Cil.html#TYPEattributes">attributes</a> -> <a href="Cil.html#TYPEattributes">attributes</a>) -> <a href="Cil.html#TYPEtyp">typ</a> -> <a href="Cil.html#TYPEtypsig">typsig</a></code></pre><div class="info ">
<div class="info-desc">
<p>Like <a href="Cil.html#VALtypeSig"><code class="code">Cil.typeSig</code></a> but customize the incorporation of attributes.
    Use ~ignoreSign:true to convert all signed integer types to unsigned,
    so that signed and unsigned will compare the same.</p>
</div>
</div>

<pre><span id="VALsetTypeSigAttrs"><span class="keyword">val</span> setTypeSigAttrs</span> : <code class="type"><a href="Cil.html#TYPEattributes">attributes</a> -> <a href="Cil.html#TYPEtypsig">typsig</a> -> <a href="Cil.html#TYPEtypsig">typsig</a></code></pre><div class="info ">
<div class="info-desc">
<p>Replace the attributes of a signature (only at top level)</p>
</div>
</div>

<pre><span id="VALtypeSigAttrs"><span class="keyword">val</span> typeSigAttrs</span> : <code class="type"><a href="Cil.html#TYPEtypsig">typsig</a> -> <a href="Cil.html#TYPEattributes">attributes</a></code></pre><div class="info ">
<div class="info-desc">
<p>Get the top-level attributes of a signature</p>
</div>
</div>
<p><b>Lvalues</b></p>

<pre><span id="VALmakeVarinfo"><span class="keyword">val</span> makeVarinfo</span> : <code class="type">bool -> string -> ?init:<a href="Cil.html#TYPEinit">init</a> -> <a href="Cil.html#TYPEtyp">typ</a> -> <a href="Cil.html#TYPEvarinfo">varinfo</a></code></pre><div class="info ">
<div class="info-desc">
<p>Make a varinfo. Use this (rarely) to make a raw varinfo. Use other
 functions to make locals (<a href="Cil.html#VALmakeLocalVar"><code class="code">Cil.makeLocalVar</code></a> or <a href="Cil.html#VALmakeFormalVar"><code class="code">Cil.makeFormalVar</code></a> or
 <a href="Cil.html#VALmakeTempVar"><code class="code">Cil.makeTempVar</code></a>) and globals (<a href="Cil.html#VALmakeGlobalVar"><code class="code">Cil.makeGlobalVar</code></a>). Note that this
 function will assign a new identifier. The first argument specifies
 whether the varinfo is for a global.</p>
</div>
</div>

<pre><span id="VALmakeFormalVar"><span class="keyword">val</span> makeFormalVar</span> : <code class="type"><a href="Cil.html#TYPEfundec">fundec</a> -> ?where:string -> string -> <a href="Cil.html#TYPEtyp">typ</a> -> <a href="Cil.html#TYPEvarinfo">varinfo</a></code></pre><div class="info ">
<div class="info-desc">
<p>Make a formal variable for a function. Insert it in both the sformals
    and the type of the function. You can optionally specify where to insert
    this one. If where = "^" then it is inserted first. If where = "$" then
    it is inserted last. Otherwise where must be the name of a formal after
    which to insert this. By default it is inserted at the end.</p>
</div>
</div>

<pre><span id="VALmakeLocalVar"><span class="keyword">val</span> makeLocalVar</span> : <code class="type"><a href="Cil.html#TYPEfundec">fundec</a> -><br>       ?insert:bool -> string -> ?init:<a href="Cil.html#TYPEinit">init</a> -> <a href="Cil.html#TYPEtyp">typ</a> -> <a href="Cil.html#TYPEvarinfo">varinfo</a></code></pre><div class="info ">
<div class="info-desc">
<p>Make a local variable and add it to a function's slocals (only if insert =
    true, which is the default). Make sure you know what you are doing if you
    set insert=false.</p>
</div>
</div>

<pre><span id="VALmakeTempVar"><span class="keyword">val</span> makeTempVar</span> : <code class="type"><a href="Cil.html#TYPEfundec">fundec</a> -><br>       ?insert:bool -><br>       ?name:string -><br>       ?descr:<a href="Pretty.html#TYPEdoc">Pretty.doc</a> -> ?descrpure:bool -> <a href="Cil.html#TYPEtyp">typ</a> -> <a href="Cil.html#TYPEvarinfo">varinfo</a></code></pre><div class="info ">
<div class="info-desc">
<p>Make a temporary variable and add it to a function's slocals. CIL will
    ensure that the name of the new variable is unique in this function, and
    will generate this name by appending a number to the specified string
    ("__cil_tmp" by default).</p>

<p>The variable will be added to the function's slocals unless you explicitly
    set insert=false.  (Make sure you know what you are doing if you set
    insert=false.)</p>

<p>Optionally, you can give the variable a description of its contents
    that will be printed by descriptiveCilPrinter.</p>
</div>
</div>

<pre><span id="VALmakeGlobalVar"><span class="keyword">val</span> makeGlobalVar</span> : <code class="type">string -> <a href="Cil.html#TYPEtyp">typ</a> -> <a href="Cil.html#TYPEvarinfo">varinfo</a></code></pre><div class="info ">
<div class="info-desc">
<p>Make a global variable. Your responsibility to make sure that the name
    is unique</p>
</div>
</div>

<pre><span id="VALcopyVarinfo"><span class="keyword">val</span> copyVarinfo</span> : <code class="type"><a href="Cil.html#TYPEvarinfo">varinfo</a> -> string -> <a href="Cil.html#TYPEvarinfo">varinfo</a></code></pre><div class="info ">
<div class="info-desc">
<p>Make a shallow copy of a <code class="code">varinfo</code> and assign a new identifier</p>
</div>
</div>

<pre><span id="VALnewVID"><span class="keyword">val</span> newVID</span> : <code class="type">unit -> int</code></pre><div class="info ">
<div class="info-desc">
<p>Generate a new variable ID. This will be different than any variable ID
 that is generated by <a href="Cil.html#VALmakeLocalVar"><code class="code">Cil.makeLocalVar</code></a> and friends</p>
</div>
</div>

<pre><span id="VALaddOffsetLval"><span class="keyword">val</span> addOffsetLval</span> : <code class="type"><a href="Cil.html#TYPEoffset">offset</a> -> <a href="Cil.html#TYPElval">lval</a> -> <a href="Cil.html#TYPElval">lval</a></code></pre><div class="info ">
<div class="info-desc">
<p>Add an offset at the end of an lvalue. Make sure the type of the lvalue
 and the offset are compatible.</p>
</div>
</div>

<pre><span id="VALaddOffset"><span class="keyword">val</span> addOffset</span> : <code class="type"><a href="Cil.html#TYPEoffset">offset</a> -> <a href="Cil.html#TYPEoffset">offset</a> -> <a href="Cil.html#TYPEoffset">offset</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">addOffset o1 o2</code> adds <code class="code">o1</code> to the end of <code class="code">o2</code>.</p>
</div>
</div>

<pre><span id="VALremoveOffsetLval"><span class="keyword">val</span> removeOffsetLval</span> : <code class="type"><a href="Cil.html#TYPElval">lval</a> -> <a href="Cil.html#TYPElval">lval</a> * <a href="Cil.html#TYPEoffset">offset</a></code></pre><div class="info ">
<div class="info-desc">
<p>Remove ONE offset from the end of an lvalue. Returns the lvalue with the
 trimmed offset and the final offset. If the final offset is <code class="code">NoOffset</code>
 then the original <code class="code">lval</code> did not have an offset.</p>
</div>
</div>

<pre><span id="VALremoveOffset"><span class="keyword">val</span> removeOffset</span> : <code class="type"><a href="Cil.html#TYPEoffset">offset</a> -> <a href="Cil.html#TYPEoffset">offset</a> * <a href="Cil.html#TYPEoffset">offset</a></code></pre><div class="info ">
<div class="info-desc">
<p>Remove ONE offset from the end of an offset sequence. Returns the
 trimmed offset and the final offset. If the final offset is <code class="code">NoOffset</code>
 then the original <code class="code">lval</code> did not have an offset.</p>
</div>
</div>

<pre><span id="VALtypeOfLval"><span class="keyword">val</span> typeOfLval</span> : <code class="type"><a href="Cil.html#TYPElval">lval</a> -> <a href="Cil.html#TYPEtyp">typ</a></code></pre><div class="info ">
<div class="info-desc">
<p>Compute the type of an lvalue</p>
</div>
</div>

<pre><span id="VALtypeOffset"><span class="keyword">val</span> typeOffset</span> : <code class="type"><a href="Cil.html#TYPEtyp">typ</a> -> <a href="Cil.html#TYPEoffset">offset</a> -> <a href="Cil.html#TYPEtyp">typ</a></code></pre><div class="info ">
<div class="info-desc">
<p>Compute the type of an offset from a base type</p>
</div>
</div>
<p><b>Values for manipulating expressions</b></p>

<pre><span id="VALzero"><span class="keyword">val</span> zero</span> : <code class="type"><a href="Cil.html#TYPEexp">exp</a></code></pre><div class="info ">
<div class="info-desc">
<p>0</p>
</div>
</div>

<pre><span id="VALone"><span class="keyword">val</span> one</span> : <code class="type"><a href="Cil.html#TYPEexp">exp</a></code></pre><div class="info ">
<div class="info-desc">
<p>1</p>
</div>
</div>

<pre><span id="VALmone"><span class="keyword">val</span> mone</span> : <code class="type"><a href="Cil.html#TYPEexp">exp</a></code></pre><div class="info ">
<div class="info-desc">
<p>-1</p>
</div>
</div>

<pre><span id="VALkintegerCilint"><span class="keyword">val</span> kintegerCilint</span> : <code class="type"><a href="Cil.html#TYPEikind">ikind</a> -> Cilint.cilint -> <a href="Cil.html#TYPEexp">exp</a></code></pre><div class="info ">
<div class="info-desc">
<p>Construct an integer of a given kind, from a cilint. If needed it
 will truncate the integer to be within the representable range for
 the given kind.</p>
</div>
</div>

<pre><span id="VALkinteger64"><span class="keyword">val</span> kinteger64</span> : <code class="type"><a href="Cil.html#TYPEikind">ikind</a> -> int64 -> <a href="Cil.html#TYPEexp">exp</a></code></pre><div class="info ">
<div class="info-desc">
<p>Construct an integer of a given kind, using OCaml's int64 type. If needed
 it will truncate the integer to be within the representable range for the
 given kind.</p>
</div>
</div>

<pre><span id="VALkinteger"><span class="keyword">val</span> kinteger</span> : <code class="type"><a href="Cil.html#TYPEikind">ikind</a> -> int -> <a href="Cil.html#TYPEexp">exp</a></code></pre><div class="info ">
<div class="info-desc">
<p>Construct an integer of a given kind. Converts the integer to int64 and
 then uses kinteger64. This might truncate the value if you use a kind
 that cannot represent the given integer. This can only happen for one of
 the Char or Short kinds</p>
</div>
</div>

<pre><span id="VALinteger"><span class="keyword">val</span> integer</span> : <code class="type">int -> <a href="Cil.html#TYPEexp">exp</a></code></pre><div class="info ">
<div class="info-desc">
<p>Construct an integer of kind IInt. On targets where C's 'int' is 16-bits,
    the integer may get truncated.</p>
</div>
</div>

<pre><span id="VALgetInteger"><span class="keyword">val</span> getInteger</span> : <code class="type"><a href="Cil.html#TYPEexp">exp</a> -> Cilint.cilint option</code></pre><div class="info ">
<div class="info-desc">
<p>If the given expression is an integer constant or a CastE'd
    integer constant, return that constant's value.
    Otherwise return None.</p>
</div>
</div>

<pre><span id="VALi64_to_int"><span class="keyword">val</span> i64_to_int</span> : <code class="type">int64 -> int</code></pre><div class="info ">
<div class="info-desc">
<p>Convert a 64-bit int to an OCaml int, or raise an exception if that
    can't be done.</p>
</div>
</div>

<pre><span id="VALcilint_to_int"><span class="keyword">val</span> cilint_to_int</span> : <code class="type">Cilint.cilint -> int</code></pre><div class="info ">
<div class="info-desc">
<p>Convert a cilint int to an OCaml int, or raise an exception if that
    can't be done.</p>
</div>
</div>

<pre><span id="VALisConstant"><span class="keyword">val</span> isConstant</span> : <code class="type"><a href="Cil.html#TYPEexp">exp</a> -> bool</code></pre><div class="info ">
<div class="info-desc">
<p>True if the expression is a compile-time constant</p>
</div>
</div>

<pre><span id="VALisConstantOffset"><span class="keyword">val</span> isConstantOffset</span> : <code class="type"><a href="Cil.html#TYPEoffset">offset</a> -> bool</code></pre><div class="info ">
<div class="info-desc">
<p>True if the given offset contains only field nanmes or constant indices.</p>
</div>
</div>

<pre><span id="VALisZero"><span class="keyword">val</span> isZero</span> : <code class="type"><a href="Cil.html#TYPEexp">exp</a> -> bool</code></pre><div class="info ">
<div class="info-desc">
<p>True if the given expression is a (possibly cast'ed) integer or character
    constant with value zero</p>
</div>
</div>

<pre><span id="VALcharConstToInt"><span class="keyword">val</span> charConstToInt</span> : <code class="type">char -> <a href="Cil.html#TYPEconstant">constant</a></code></pre><div class="info ">
<div class="info-desc">
<p>Given the character c in a (CChr c), sign-extend it to 32 bits.
    (This is the official way of interpreting character constants, according to
    ISO C 6.4.4.4.10, which says that character constants are chars cast to ints)
    Returns CInt64(sign-extened c, IInt, None)</p>
</div>
</div>

<pre><span id="VALconstFold"><span class="keyword">val</span> constFold</span> : <code class="type">bool -> <a href="Cil.html#TYPEexp">exp</a> -> <a href="Cil.html#TYPEexp">exp</a></code></pre><div class="info ">
<div class="info-desc">
<p>Do constant folding on an expression. If the first argument is true then
    will also compute compiler-dependent expressions such as sizeof.
    See also <a href="Cil.html#VALconstFoldVisitor"><code class="code">Cil.constFoldVisitor</code></a>, which will run constFold on all
    expressions in a given AST node.</p>
</div>
</div>

<pre><span id="VALconstFoldBinOp"><span class="keyword">val</span> constFoldBinOp</span> : <code class="type">bool -> <a href="Cil.html#TYPEbinop">binop</a> -> <a href="Cil.html#TYPEexp">exp</a> -> <a href="Cil.html#TYPEexp">exp</a> -> <a href="Cil.html#TYPEtyp">typ</a> -> <a href="Cil.html#TYPEexp">exp</a></code></pre><div class="info ">
<div class="info-desc">
<p>Do constant folding on a binary operation. The bulk of the work done by
    <code class="code">constFold</code> is done here. If the first argument is true then
    will also compute compiler-dependent expressions such as sizeof</p>
</div>
</div>

<pre><span id="VALincrem"><span class="keyword">val</span> increm</span> : <code class="type"><a href="Cil.html#TYPEexp">exp</a> -> int -> <a href="Cil.html#TYPEexp">exp</a></code></pre><div class="info ">
<div class="info-desc">
<p>Increment an expression. Can be arithmetic or pointer type</p>
</div>
</div>

<pre><span id="VALvar"><span class="keyword">val</span> var</span> : <code class="type"><a href="Cil.html#TYPEvarinfo">varinfo</a> -> <a href="Cil.html#TYPElval">lval</a></code></pre><div class="info ">
<div class="info-desc">
<p>Makes an lvalue out of a given variable</p>
</div>
</div>

<pre><span id="VALmkAddrOf"><span class="keyword">val</span> mkAddrOf</span> : <code class="type"><a href="Cil.html#TYPElval">lval</a> -> <a href="Cil.html#TYPEexp">exp</a></code></pre><div class="info ">
<div class="info-desc">
<p>Make an AddrOf. Given an lvalue of type T will give back an expression of
    type ptr(T). It optimizes somewhat expressions like "&amp; v" and "&amp; v<code class="code">0</code>"</p>
</div>
</div>

<pre><span id="VALmkAddrOrStartOf"><span class="keyword">val</span> mkAddrOrStartOf</span> : <code class="type"><a href="Cil.html#TYPElval">lval</a> -> <a href="Cil.html#TYPEexp">exp</a></code></pre><div class="info ">
<div class="info-desc">
<p>Like mkAddrOf except if the type of lval is an array then it uses
    StartOf. This is the right operation for getting a pointer to the start
    of the storage denoted by lval.</p>
</div>
</div>

<pre><span id="VALmkMem"><span class="keyword">val</span> mkMem</span> : <code class="type">addr:<a href="Cil.html#TYPEexp">exp</a> -> off:<a href="Cil.html#TYPEoffset">offset</a> -> <a href="Cil.html#TYPElval">lval</a></code></pre><div class="info ">
<div class="info-desc">
<p>Make a Mem, while optimizing AddrOf. The type of the addr must be
    TPtr(t) and the type of the resulting lval is t. Note that in CIL the
    implicit conversion between an array and the pointer to the first
    element does not apply. You must do the conversion yourself using
    StartOf</p>
</div>
</div>

<pre><span id="VALmkString"><span class="keyword">val</span> mkString</span> : <code class="type">string -> <a href="Cil.html#TYPEexp">exp</a></code></pre><div class="info ">
<div class="info-desc">
<p>Make an expression that is a string constant (of pointer type)</p>
</div>
</div>

<pre><span id="VALmkCastT"><span class="keyword">val</span> mkCastT</span> : <code class="type">e:<a href="Cil.html#TYPEexp">exp</a> -> oldt:<a href="Cil.html#TYPEtyp">typ</a> -> newt:<a href="Cil.html#TYPEtyp">typ</a> -> <a href="Cil.html#TYPEexp">exp</a></code></pre><div class="info ">
<div class="info-desc">
<p>Construct a cast when having the old type of the expression. If the new
 type is the same as the old type, then no cast is added.</p>
</div>
</div>

<pre><span id="VALmkCast"><span class="keyword">val</span> mkCast</span> : <code class="type">e:<a href="Cil.html#TYPEexp">exp</a> -> newt:<a href="Cil.html#TYPEtyp">typ</a> -> <a href="Cil.html#TYPEexp">exp</a></code></pre><div class="info ">
<div class="info-desc">
<p>Like <a href="Cil.html#VALmkCastT"><code class="code">Cil.mkCastT</code></a> but uses typeOf to get <code class="code">oldt</code></p>
</div>
</div>

<pre><span id="VALstripCasts"><span class="keyword">val</span> stripCasts</span> : <code class="type"><a href="Cil.html#TYPEexp">exp</a> -> <a href="Cil.html#TYPEexp">exp</a></code></pre><div class="info ">
<div class="info-desc">
<p>Removes casts from this expression, but ignores casts within
    other expression constructs.  So we delete the (A) and (B) casts from
    "(A)(B)(x + (C)y)", but leave the (C) cast.</p>
</div>
</div>

<pre><span id="VALtypeOf"><span class="keyword">val</span> typeOf</span> : <code class="type"><a href="Cil.html#TYPEexp">exp</a> -> <a href="Cil.html#TYPEtyp">typ</a></code></pre><div class="info ">
<div class="info-desc">
<p>Compute the type of an expression</p>
</div>
</div>

<pre><span id="VALparseInt"><span class="keyword">val</span> parseInt</span> : <code class="type">string -> <a href="Cil.html#TYPEexp">exp</a></code></pre><div class="info ">
<div class="info-desc">
<p>Convert a string representing a C integer literal to an expression.
 Handles the prefixes 0x and 0 and the suffixes L, U, UL, LL, ULL</p>
</div>
</div>
<p><b>Values for manipulating statements</b></p>

<pre><span id="VALmkStmt"><span class="keyword">val</span> mkStmt</span> : <code class="type"><a href="Cil.html#TYPEstmtkind">stmtkind</a> -> <a href="Cil.html#TYPEstmt">stmt</a></code></pre><div class="info ">
<div class="info-desc">
<p>Construct a statement, given its kind. Initialize the <code class="code">sid</code> field to -1,
    and <code class="code">labels</code>, <code class="code">succs</code> and <code class="code">preds</code> to the empty list</p>
</div>
</div>

<pre><span id="VALmkBlock"><span class="keyword">val</span> mkBlock</span> : <code class="type"><a href="Cil.html#TYPEstmt">stmt</a> list -> <a href="Cil.html#TYPEblock">block</a></code></pre><div class="info ">
<div class="info-desc">
<p>Construct a block with no attributes, given a list of statements</p>
</div>
</div>

<pre><span id="VALmkStmtOneInstr"><span class="keyword">val</span> mkStmtOneInstr</span> : <code class="type"><a href="Cil.html#TYPEinstr">instr</a> -> <a href="Cil.html#TYPEstmt">stmt</a></code></pre><div class="info ">
<div class="info-desc">
<p>Construct a statement consisting of just one instruction</p>
</div>
</div>

<pre><span id="VALcompactStmts"><span class="keyword">val</span> compactStmts</span> : <code class="type"><a href="Cil.html#TYPEstmt">stmt</a> list -> <a href="Cil.html#TYPEstmt">stmt</a> list</code></pre><div class="info ">
<div class="info-desc">
<p>Try to compress statements so as to get maximal basic blocks.
 use this instead of List.@ because you get fewer basic blocks</p>
</div>
</div>

<pre><span id="VALmkEmptyStmt"><span class="keyword">val</span> mkEmptyStmt</span> : <code class="type">unit -> <a href="Cil.html#TYPEstmt">stmt</a></code></pre><div class="info ">
<div class="info-desc">
<p>Returns an empty statement (of kind <code class="code">Instr</code>)</p>
</div>
</div>

<pre><span id="VALdummyInstr"><span class="keyword">val</span> dummyInstr</span> : <code class="type"><a href="Cil.html#TYPEinstr">instr</a></code></pre><div class="info ">
<div class="info-desc">
<p>A instr to serve as a placeholder</p>
</div>
</div>

<pre><span id="VALdummyStmt"><span class="keyword">val</span> dummyStmt</span> : <code class="type"><a href="Cil.html#TYPEstmt">stmt</a></code></pre><div class="info ">
<div class="info-desc">
<p>A statement consisting of just <code class="code">dummyInstr</code></p>
</div>
</div>

<pre><span id="VALmkWhile"><span class="keyword">val</span> mkWhile</span> : <code class="type">guard:<a href="Cil.html#TYPEexp">exp</a> -> body:<a href="Cil.html#TYPEstmt">stmt</a> list -> <a href="Cil.html#TYPEstmt">stmt</a> list</code></pre><div class="info ">
<div class="info-desc">
<p>Make a while loop. Can contain Break or Continue</p>
</div>
</div>

<pre><span id="VALmkForIncr"><span class="keyword">val</span> mkForIncr</span> : <code class="type">iter:<a href="Cil.html#TYPEvarinfo">varinfo</a> -><br>       first:<a href="Cil.html#TYPEexp">exp</a> -><br>       stopat:<a href="Cil.html#TYPEexp">exp</a> -> incr:<a href="Cil.html#TYPEexp">exp</a> -> body:<a href="Cil.html#TYPEstmt">stmt</a> list -> <a href="Cil.html#TYPEstmt">stmt</a> list</code></pre><div class="info ">
<div class="info-desc">
<p>Make a for loop for(i=start; i&lt;past; i += incr) { ... }. The body
    can contain Break but not Continue. Can be used with i a pointer
    or an integer. Start and done must have the same type but incr
    must be an integer</p>
</div>
</div>

<pre><span id="VALmkFor"><span class="keyword">val</span> mkFor</span> : <code class="type">start:<a href="Cil.html#TYPEstmt">stmt</a> list -><br>       guard:<a href="Cil.html#TYPEexp">exp</a> -> next:<a href="Cil.html#TYPEstmt">stmt</a> list -> body:<a href="Cil.html#TYPEstmt">stmt</a> list -> <a href="Cil.html#TYPEstmt">stmt</a> list</code></pre><div class="info ">
<div class="info-desc">
<p>Make a for loop for(start; guard; next) { ... }. The body can
    contain Break but not Continue !!!</p>
</div>
</div>
<p><b>Values for manipulating attributes</b></p>

<pre><code><span id="TYPEattributeClass"><span class="keyword">type</span> <code class="type"></code>attributeClass</span> = </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTattributeClass.AttrName"><span class="constructor">AttrName</span></span> <span class="keyword">of</span> <code class="type">bool</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>Attribute of a name. If argument is true and we are on MSVC then
      the attribute is printed using __declspec as part of the storage
      specifier</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTattributeClass.AttrFunType"><span class="constructor">AttrFunType</span></span> <span class="keyword">of</span> <code class="type">bool</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>Attribute of a function type. If argument is true and we are on
      MSVC then the attribute is printed just before the function name</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTattributeClass.AttrType"><span class="constructor">AttrType</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>Attribute of a type</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info ">
<div class="info-desc">
<p>Various classes of attributes</p>
</div>
</div>


<pre><span id="VALattributeHash"><span class="keyword">val</span> attributeHash</span> : <code class="type">(string, <a href="Cil.html#TYPEattributeClass">attributeClass</a>) Hashtbl.t</code></pre><div class="info ">
<div class="info-desc">
<p>This table contains the mapping of predefined attributes to classes.
    Extend this table with more attributes as you need. This table is used to
    determine how to associate attributes with names or types</p>
</div>
</div>

<pre><span id="VALpartitionAttributes"><span class="keyword">val</span> partitionAttributes</span> : <code class="type">default:<a href="Cil.html#TYPEattributeClass">attributeClass</a> -><br>       <a href="Cil.html#TYPEattributes">attributes</a> -><br>       <a href="Cil.html#TYPEattribute">attribute</a> list * <a href="Cil.html#TYPEattribute">attribute</a> list * <a href="Cil.html#TYPEattribute">attribute</a> list</code></pre><div class="info ">
<div class="info-desc">
<p>Partition the attributes into classes:name attributes, function type,
    and type attributes</p>
</div>
</div>

<pre><span id="VALaddAttribute"><span class="keyword">val</span> addAttribute</span> : <code class="type"><a href="Cil.html#TYPEattribute">attribute</a> -> <a href="Cil.html#TYPEattributes">attributes</a> -> <a href="Cil.html#TYPEattributes">attributes</a></code></pre><div class="info ">
<div class="info-desc">
<p>Add an attribute. Maintains the attributes in sorted order of the second
    argument</p>
</div>
</div>

<pre><span id="VALaddAttributes"><span class="keyword">val</span> addAttributes</span> : <code class="type"><a href="Cil.html#TYPEattribute">attribute</a> list -> <a href="Cil.html#TYPEattributes">attributes</a> -> <a href="Cil.html#TYPEattributes">attributes</a></code></pre><div class="info ">
<div class="info-desc">
<p>Add a list of attributes. Maintains the attributes in sorted order. The
    second argument must be sorted, but not necessarily the first</p>
</div>
</div>

<pre><span id="VALdropAttribute"><span class="keyword">val</span> dropAttribute</span> : <code class="type">string -> <a href="Cil.html#TYPEattributes">attributes</a> -> <a href="Cil.html#TYPEattributes">attributes</a></code></pre><div class="info ">
<div class="info-desc">
<p>Remove all attributes with the given name. Maintains the attributes in
    sorted order.</p>
</div>
</div>

<pre><span id="VALdropAttributes"><span class="keyword">val</span> dropAttributes</span> : <code class="type">string list -> <a href="Cil.html#TYPEattributes">attributes</a> -> <a href="Cil.html#TYPEattributes">attributes</a></code></pre><div class="info ">
<div class="info-desc">
<p>Remove all attributes with names appearing in the string list.
  Maintains the attributes in sorted order</p>
</div>
</div>

<pre><span id="VALfilterAttributes"><span class="keyword">val</span> filterAttributes</span> : <code class="type">string -> <a href="Cil.html#TYPEattributes">attributes</a> -> <a href="Cil.html#TYPEattributes">attributes</a></code></pre><div class="info ">
<div class="info-desc">
<p>Retains attributes with the given name</p>
</div>
</div>

<pre><span id="VALhasAttribute"><span class="keyword">val</span> hasAttribute</span> : <code class="type">string -> <a href="Cil.html#TYPEattributes">attributes</a> -> bool</code></pre><div class="info ">
<div class="info-desc">
<p>True if the named attribute appears in the attribute list. The list of
    attributes must be sorted.</p>
</div>
</div>

<pre><span id="VALtypeAttrs"><span class="keyword">val</span> typeAttrs</span> : <code class="type"><a href="Cil.html#TYPEtyp">typ</a> -> <a href="Cil.html#TYPEattribute">attribute</a> list</code></pre><div class="info ">
<div class="info-desc">
<p>Returns all the attributes contained in a type. This requires a traversal
    of the type structure, in case of composite, enumeration and named types</p>
</div>
</div>

<pre><span id="VALsetTypeAttrs"><span class="keyword">val</span> setTypeAttrs</span> : <code class="type"><a href="Cil.html#TYPEtyp">typ</a> -> <a href="Cil.html#TYPEattributes">attributes</a> -> <a href="Cil.html#TYPEtyp">typ</a></code></pre>
<pre><span id="VALtypeAddAttributes"><span class="keyword">val</span> typeAddAttributes</span> : <code class="type"><a href="Cil.html#TYPEattribute">attribute</a> list -> <a href="Cil.html#TYPEtyp">typ</a> -> <a href="Cil.html#TYPEtyp">typ</a></code></pre><div class="info ">
<div class="info-desc">
<p>Add some attributes to a type</p>
</div>
</div>

<pre><span id="VALtypeRemoveAttributes"><span class="keyword">val</span> typeRemoveAttributes</span> : <code class="type">string list -> <a href="Cil.html#TYPEtyp">typ</a> -> <a href="Cil.html#TYPEtyp">typ</a></code></pre><div class="info ">
<div class="info-desc">
<p>Remove all attributes with the given names from a type. Note that this
    does not remove attributes from typedef and tag definitions, just from
    their uses</p>
</div>
</div>

<pre><span id="VALexpToAttrParam"><span class="keyword">val</span> expToAttrParam</span> : <code class="type"><a href="Cil.html#TYPEexp">exp</a> -> <a href="Cil.html#TYPEattrparam">attrparam</a></code></pre><div class="info ">
<div class="info-desc">
<p>Convert an expression into an attrparam, if possible. Otherwise raise
    NotAnAttrParam with the offending subexpression</p>
</div>
</div>

<pre><span id="EXCEPTIONNotAnAttrParam"><span class="keyword">exception</span> NotAnAttrParam</span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEexp">exp</a></code></pre>
<p><b>The visitor</b></p>

<pre><code><span id="TYPEvisitAction"><span class="keyword">type</span> <code class="type">'a</code> visitAction</span> = </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTvisitAction.SkipChildren"><span class="constructor">SkipChildren</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>Do not visit the children. Return
                                            the node as it is.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTvisitAction.DoChildren"><span class="constructor">DoChildren</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>Continue with the children of this
                                            node. Rebuild the node on return
                                            if any of the children changes
                                            (use == test)</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTvisitAction.ChangeTo"><span class="constructor">ChangeTo</span></span> <span class="keyword">of</span> <code class="type">'a</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>Replace the expression with the
                                            given one</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTvisitAction.ChangeDoChildrenPost"><span class="constructor">ChangeDoChildrenPost</span></span> <span class="keyword">of</span> <code class="type">'a * ('a -> 'a)</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>First consider that the entire
                                                exp is replaced by the first
                                                parameter. Then continue with
                                                the children. On return rebuild
                                                the node if any of the children
                                                has changed and then apply the
                                                function on the node</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info ">
<div class="info-desc">
<p>Different visiting actions. 'a will be instantiated with <code class="code">exp</code>, <code class="code">instr</code>,
    etc.</p>
</div>
</div>


<pre><span id="TYPEcilVisitor"><span class="keyword">class type</span> <a href="Cil.cilVisitor-c.html">cilVisitor</a></span> = <code class="code">object</code> <a href="Cil.cilVisitor-c.html">..</a> <code class="code">end</code></pre><div class="info">
<p>A visitor interface for traversing CIL trees.</p>

</div>

<pre><span id="TYPEnopCilVisitor"><span class="keyword">class</span> <a href="Cil.nopCilVisitor-c.html">nopCilVisitor</a></span> : <code class="type"></code><code class="type"><a href="Cil.cilVisitor-c.html">cilVisitor</a></code></pre><div class="info">
<p>Default Visitor.</p>

</div>

<pre><span id="VALvisitCilFile"><span class="keyword">val</span> visitCilFile</span> : <code class="type"><a href="Cil.cilVisitor-c.html">cilVisitor</a> -> <a href="Cil.html#TYPEfile">file</a> -> unit</code></pre><div class="info ">
<div class="info-desc">
<p>Visit a file. This will will re-cons all globals TWICE (so that it is
 tail-recursive). Use <a href="Cil.html#VALvisitCilFileSameGlobals"><code class="code">Cil.visitCilFileSameGlobals</code></a> if your visitor will
 not change the list of globals.</p>
</div>
</div>

<pre><span id="VALvisitCilFileSameGlobals"><span class="keyword">val</span> visitCilFileSameGlobals</span> : <code class="type"><a href="Cil.cilVisitor-c.html">cilVisitor</a> -> <a href="Cil.html#TYPEfile">file</a> -> unit</code></pre><div class="info ">
<div class="info-desc">
<p>A visitor for the whole file that does not change the globals (but maybe
 changes things inside the globals). Use this function instead of
 <a href="Cil.html#VALvisitCilFile"><code class="code">Cil.visitCilFile</code></a> whenever appropriate because it is more efficient for
 long files.</p>
</div>
</div>

<pre><span id="VALvisitCilGlobal"><span class="keyword">val</span> visitCilGlobal</span> : <code class="type"><a href="Cil.cilVisitor-c.html">cilVisitor</a> -> <a href="Cil.html#TYPEglobal">global</a> -> <a href="Cil.html#TYPEglobal">global</a> list</code></pre><div class="info ">
<div class="info-desc">
<p>Visit a global</p>
</div>
</div>

<pre><span id="VALvisitCilFunction"><span class="keyword">val</span> visitCilFunction</span> : <code class="type"><a href="Cil.cilVisitor-c.html">cilVisitor</a> -> <a href="Cil.html#TYPEfundec">fundec</a> -> <a href="Cil.html#TYPEfundec">fundec</a></code></pre><div class="info ">
<div class="info-desc">
<p>Visit a function definition</p>
</div>
</div>

<pre><span id="VALvisitCilExpr"><span class="keyword">val</span> visitCilExpr</span> : <code class="type"><a href="Cil.cilVisitor-c.html">cilVisitor</a> -> <a href="Cil.html#TYPEexp">exp</a> -> <a href="Cil.html#TYPEexp">exp</a></code></pre>
<pre><span id="VALvisitCilLval"><span class="keyword">val</span> visitCilLval</span> : <code class="type"><a href="Cil.cilVisitor-c.html">cilVisitor</a> -> <a href="Cil.html#TYPElval">lval</a> -> <a href="Cil.html#TYPElval">lval</a></code></pre><div class="info ">
<div class="info-desc">
<p>Visit an lvalue</p>
</div>
</div>

<pre><span id="VALvisitCilOffset"><span class="keyword">val</span> visitCilOffset</span> : <code class="type"><a href="Cil.cilVisitor-c.html">cilVisitor</a> -> <a href="Cil.html#TYPEoffset">offset</a> -> <a href="Cil.html#TYPEoffset">offset</a></code></pre><div class="info ">
<div class="info-desc">
<p>Visit an lvalue or recursive offset</p>
</div>
</div>

<pre><span id="VALvisitCilInitOffset"><span class="keyword">val</span> visitCilInitOffset</span> : <code class="type"><a href="Cil.cilVisitor-c.html">cilVisitor</a> -> <a href="Cil.html#TYPEoffset">offset</a> -> <a href="Cil.html#TYPEoffset">offset</a></code></pre><div class="info ">
<div class="info-desc">
<p>Visit an initializer offset</p>
</div>
</div>

<pre><span id="VALvisitCilInstr"><span class="keyword">val</span> visitCilInstr</span> : <code class="type"><a href="Cil.cilVisitor-c.html">cilVisitor</a> -> <a href="Cil.html#TYPEinstr">instr</a> -> <a href="Cil.html#TYPEinstr">instr</a> list</code></pre><div class="info ">
<div class="info-desc">
<p>Visit an instruction</p>
</div>
</div>

<pre><span id="VALvisitCilStmt"><span class="keyword">val</span> visitCilStmt</span> : <code class="type"><a href="Cil.cilVisitor-c.html">cilVisitor</a> -> <a href="Cil.html#TYPEstmt">stmt</a> -> <a href="Cil.html#TYPEstmt">stmt</a></code></pre><div class="info ">
<div class="info-desc">
<p>Visit a statement</p>
</div>
</div>

<pre><span id="VALvisitCilBlock"><span class="keyword">val</span> visitCilBlock</span> : <code class="type"><a href="Cil.cilVisitor-c.html">cilVisitor</a> -> <a href="Cil.html#TYPEblock">block</a> -> <a href="Cil.html#TYPEblock">block</a></code></pre><div class="info ">
<div class="info-desc">
<p>Visit a block</p>
</div>
</div>

<pre><span id="VALvisitCilType"><span class="keyword">val</span> visitCilType</span> : <code class="type"><a href="Cil.cilVisitor-c.html">cilVisitor</a> -> <a href="Cil.html#TYPEtyp">typ</a> -> <a href="Cil.html#TYPEtyp">typ</a></code></pre><div class="info ">
<div class="info-desc">
<p>Visit a type</p>
</div>
</div>

<pre><span id="VALvisitCilVarDecl"><span class="keyword">val</span> visitCilVarDecl</span> : <code class="type"><a href="Cil.cilVisitor-c.html">cilVisitor</a> -> <a href="Cil.html#TYPEvarinfo">varinfo</a> -> <a href="Cil.html#TYPEvarinfo">varinfo</a></code></pre><div class="info ">
<div class="info-desc">
<p>Visit a variable declaration</p>
</div>
</div>

<pre><span id="VALvisitCilInit"><span class="keyword">val</span> visitCilInit</span> : <code class="type"><a href="Cil.cilVisitor-c.html">cilVisitor</a> -> <a href="Cil.html#TYPEvarinfo">varinfo</a> -> <a href="Cil.html#TYPEoffset">offset</a> -> <a href="Cil.html#TYPEinit">init</a> -> <a href="Cil.html#TYPEinit">init</a></code></pre><div class="info ">
<div class="info-desc">
<p>Visit an initializer, pass also the variable to which this belongs and the
 offset.</p>
</div>
</div>

<pre><span id="VALvisitCilAttributes"><span class="keyword">val</span> visitCilAttributes</span> : <code class="type"><a href="Cil.cilVisitor-c.html">cilVisitor</a> -> <a href="Cil.html#TYPEattribute">attribute</a> list -> <a href="Cil.html#TYPEattribute">attribute</a> list</code></pre><div class="info ">
<div class="info-desc">
<p>Visit a list of attributes</p>
</div>
</div>
<p><b>Utility functions</b></p>

<pre><span id="VALmsvcMode"><span class="keyword">val</span> msvcMode</span> : <code class="type">bool ref</code></pre><div class="info ">
<div class="info-desc">
<p>Whether the pretty printer should print output for the MS VC compiler.
    Default is GCC. After you set this function you should call <a href="Cil.html#VALinitCIL"><code class="code">Cil.initCIL</code></a>.</p>
</div>
</div>

<pre><span id="VALmakeStaticGlobal"><span class="keyword">val</span> makeStaticGlobal</span> : <code class="type">bool ref</code></pre><div class="info ">
<div class="info-desc">
<p>Whether to convert local static variables into global static variables</p>
</div>
</div>

<pre><span id="VALuseLogicalOperators"><span class="keyword">val</span> useLogicalOperators</span> : <code class="type">bool ref</code></pre><div class="info ">
<div class="info-desc">
<p>Whether to use the logical operands LAnd and LOr. By default, do not use
 them because they are unlike other expressions and do not evaluate both of
 their operands</p>
</div>
</div>

<pre><span id="VALuseComputedGoto"><span class="keyword">val</span> useComputedGoto</span> : <code class="type">bool ref</code></pre><div class="info ">
<div class="info-desc">
<p>Whether to use GCC's computed gotos.  By default, do not use them and
 replace them by a switch.</p>
</div>
</div>

<pre><span id="VALuseCaseRange"><span class="keyword">val</span> useCaseRange</span> : <code class="type">bool ref</code></pre><div class="info ">
<div class="info-desc">
<p>Whether to expand ranges of values in case statements.  By default, expand
 them and do not use the CaseRange constructor.</p>
</div>
</div>

<pre><span id="VALcaseRangeFold"><span class="keyword">val</span> caseRangeFold</span> : <code class="type"><a href="Cil.html#TYPElabel">label</a> list -> <a href="Cil.html#TYPElabel">label</a> list</code></pre><div class="info ">
<div class="info-desc">
<p>Fold every <code class="code">CaseRange</code> in a list of labels into the corresponding list of
 <code class="code">Case</code> labels.  Raises <a href="Errormsg.html#EXCEPTIONError"><code class="code">Errormsg.Error</code></a> if one of the ranges cannot be
 constant folded.</p>
</div>
</div>

<pre><span id="VALoldstyleExternInline"><span class="keyword">val</span> oldstyleExternInline</span> : <code class="type">bool ref</code></pre><div class="info ">
<div class="info-desc">
<p>Set this to true to get old-style handling of gcc's extern inline C extension:
    old-style: the extern inline definition is used until the actual definition is
     seen (as long as optimization is enabled)
    new-style: the extern inline definition is used only if there is no actual
     definition (as long as optimization is enabled)
    Note that CIL assumes that optimization is always enabled ;-)</p>
</div>
</div>

<pre><span id="VALconstFoldVisitor"><span class="keyword">val</span> constFoldVisitor</span> : <code class="type">bool -> <a href="Cil.cilVisitor-c.html">cilVisitor</a></code></pre><div class="info ">
<div class="info-desc">
<p>A visitor that does constant folding. Pass as argument whether you want
 machine specific simplifications to be done, or not.</p>
</div>
</div>

<pre><code><span id="TYPElineDirectiveStyle"><span class="keyword">type</span> <code class="type"></code>lineDirectiveStyle</span> = </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTlineDirectiveStyle.LineComment"><span class="constructor">LineComment</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>Before every element, print the line
 number in comments. This is ignored by
 processing tools (thus errors are reproted
 in the CIL output), but useful for
 visual inspection</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTlineDirectiveStyle.LineCommentSparse"><span class="constructor">LineCommentSparse</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>Like LineComment but only print a line
 directive for a new source line</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTlineDirectiveStyle.LinePreprocessorInput"><span class="constructor">LinePreprocessorInput</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>Use # nnn directives (in gcc mode)</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTlineDirectiveStyle.LinePreprocessorOutput"><span class="constructor">LinePreprocessorOutput</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>Use #line directives</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info ">
<div class="info-desc">
<p>Styles of printing line directives</p>
</div>
</div>


<pre><span id="VALlineDirectiveStyle"><span class="keyword">val</span> lineDirectiveStyle</span> : <code class="type"><a href="Cil.html#TYPElineDirectiveStyle">lineDirectiveStyle</a> option ref</code></pre><div class="info ">
<div class="info-desc">
<p>How to print line directives</p>
</div>
</div>

<pre><span id="VALprint_CIL_Input"><span class="keyword">val</span> print_CIL_Input</span> : <code class="type">bool ref</code></pre><div class="info ">
<div class="info-desc">
<p>Whether we print something that will only be used as input to our own
 parser. In that case we are a bit more liberal in what we print</p>
</div>
</div>

<pre><span id="VALprintCilAsIs"><span class="keyword">val</span> printCilAsIs</span> : <code class="type">bool ref</code></pre><div class="info ">
<div class="info-desc">
<p>Whether to print the CIL as they are, without trying to be smart and
 print nicer code. Normally this is false, in which case the pretty
 printer will turn the while(1) loops of CIL into nicer loops, will not
 print empty "else" blocks, etc. There is one case howewer in which if you
 turn this on you will get code that does not compile: if you use varargs
 the __builtin_va_arg function will be printed in its internal form.</p>
</div>
</div>

<pre><span id="VALlineLength"><span class="keyword">val</span> lineLength</span> : <code class="type">int ref</code></pre><div class="info ">
<div class="info-desc">
<p>The length used when wrapping output lines.  Setting this variable to
 a large integer will prevent wrapping and make #line directives more
 accurate.</p>
</div>
</div>

<pre><span id="VALforgcc"><span class="keyword">val</span> forgcc</span> : <code class="type">string -> string</code></pre><div class="info ">
<div class="info-desc">
<p>Return the string 's' if we're printing output for gcc, suppres
  it if we're printing for CIL to parse back in.  the purpose is to
  hide things from gcc that it complains about, but still be able
  to do lossless transformations when CIL is the consumer</p>
</div>
</div>
<p><b>Debugging support</b></p>

<pre><span id="VALcurrentLoc"><span class="keyword">val</span> currentLoc</span> : <code class="type"><a href="Cil.html#TYPElocation">location</a> ref</code></pre><div class="info ">
<div class="info-desc">
<p>A reference to the current location. If you are careful to set this to
 the current location then you can use some built-in logging functions that
 will print the location.</p>
</div>
</div>

<pre><span id="VALcurrentGlobal"><span class="keyword">val</span> currentGlobal</span> : <code class="type"><a href="Cil.html#TYPEglobal">global</a> ref</code></pre><div class="info ">
<div class="info-desc">
<p>A reference to the current global being visited</p>
</div>
</div>
<p>CIL has a fairly easy to use mechanism for printing error messages. This
 mechanism is built on top of the pretty-printer mechanism (see
 <a href="Pretty.html#TYPEdoc"><code class="code">Pretty.doc</code></a>) and the error-message modules (see <a href="Errormsg.html#VALerror"><code class="code">Errormsg.error</code></a>).</p>

<p>Here is a typical example for printing a log message:</p>
<pre class="verbatim">ignore (Errormsg.log "Expression %a is not positive (at %s:%i)\n"
                        d_exp e loc.file loc.line)
</pre>
<p>and here is an example of how you print a fatal error message that stop the
 execution:</p>
<pre class="verbatim">Errormsg.s (Errormsg.bug "Why am I here?")
</pre>
<p>Notice that you can use C format strings with some extension. The most
    useful extension is "%a" that means to consumer the next two argument from
    the argument list and to apply the first to <code class="code">unit</code> and then to the second
    and to print the resulting <a href="Pretty.html#TYPEdoc"><code class="code">Pretty.doc</code></a>. For each major type in CIL there is
    a corresponding function that pretty-prints an element of that type:</p>

<pre><span id="VALd_loc"><span class="keyword">val</span> d_loc</span> : <code class="type">unit -> <a href="Cil.html#TYPElocation">location</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info ">
<div class="info-desc">
<p>Pretty-print a location</p>
</div>
</div>

<pre><span id="VALd_thisloc"><span class="keyword">val</span> d_thisloc</span> : <code class="type">unit -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info ">
<div class="info-desc">
<p>Pretty-print the <a href="Cil.html#VALcurrentLoc"><code class="code">Cil.currentLoc</code></a></p>
</div>
</div>

<pre><span id="VALd_ikind"><span class="keyword">val</span> d_ikind</span> : <code class="type">unit -> <a href="Cil.html#TYPEikind">ikind</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info ">
<div class="info-desc">
<p>Pretty-print an integer of a given kind</p>
</div>
</div>

<pre><span id="VALd_fkind"><span class="keyword">val</span> d_fkind</span> : <code class="type">unit -> <a href="Cil.html#TYPEfkind">fkind</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info ">
<div class="info-desc">
<p>Pretty-print a floating-point kind</p>
</div>
</div>

<pre><span id="VALd_storage"><span class="keyword">val</span> d_storage</span> : <code class="type">unit -> <a href="Cil.html#TYPEstorage">storage</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info ">
<div class="info-desc">
<p>Pretty-print storage-class information</p>
</div>
</div>

<pre><span id="VALd_const"><span class="keyword">val</span> d_const</span> : <code class="type">unit -> <a href="Cil.html#TYPEconstant">constant</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info ">
<div class="info-desc">
<p>Pretty-print a constant</p>
</div>
</div>

<pre><span id="VALderefStarLevel"><span class="keyword">val</span> derefStarLevel</span> : <code class="type">int</code></pre>
<pre><span id="VALindexLevel"><span class="keyword">val</span> indexLevel</span> : <code class="type">int</code></pre>
<pre><span id="VALarrowLevel"><span class="keyword">val</span> arrowLevel</span> : <code class="type">int</code></pre>
<pre><span id="VALaddrOfLevel"><span class="keyword">val</span> addrOfLevel</span> : <code class="type">int</code></pre>
<pre><span id="VALadditiveLevel"><span class="keyword">val</span> additiveLevel</span> : <code class="type">int</code></pre>
<pre><span id="VALcomparativeLevel"><span class="keyword">val</span> comparativeLevel</span> : <code class="type">int</code></pre>
<pre><span id="VALbitwiseLevel"><span class="keyword">val</span> bitwiseLevel</span> : <code class="type">int</code></pre>
<pre><span id="VALgetParenthLevel"><span class="keyword">val</span> getParenthLevel</span> : <code class="type"><a href="Cil.html#TYPEexp">exp</a> -> int</code></pre><div class="info ">
<div class="info-desc">
<p>Parentheses level. An expression "a op b" is printed parenthesized if its
 parentheses level is &gt;= that that of its context. Identifiers have the
 lowest level and weakly binding operators (e.g. |) have the largest level.
 The correctness criterion is that a smaller level MUST correspond to a
 stronger precedence!</p>
</div>
</div>

<pre><span id="TYPEcilPrinter"><span class="keyword">class type</span> <a href="Cil.cilPrinter-c.html">cilPrinter</a></span> = <code class="code">object</code> <a href="Cil.cilPrinter-c.html">..</a> <code class="code">end</code></pre><div class="info">
<p>A printer interface for CIL trees.</p>

</div>

<pre><span id="TYPEdefaultCilPrinterClass"><span class="keyword">class</span> <a href="Cil.defaultCilPrinterClass-c.html">defaultCilPrinterClass</a></span> : <code class="type"></code><code class="type"><a href="Cil.cilPrinter-c.html">cilPrinter</a></code></pre>
<pre><span id="VALdefaultCilPrinter"><span class="keyword">val</span> defaultCilPrinter</span> : <code class="type"><a href="Cil.cilPrinter-c.html">cilPrinter</a></code></pre>
<pre><span id="TYPEplainCilPrinterClass"><span class="keyword">class</span> <a href="Cil.plainCilPrinterClass-c.html">plainCilPrinterClass</a></span> : <code class="type"></code><code class="type"><a href="Cil.cilPrinter-c.html">cilPrinter</a></code></pre><div class="info">
<p>These are pretty-printers that will show you more details on the internal
 CIL representation, without trying hard to make it look like C</p>

</div>

<pre><span id="VALplainCilPrinter"><span class="keyword">val</span> plainCilPrinter</span> : <code class="type"><a href="Cil.cilPrinter-c.html">cilPrinter</a></code></pre>
<pre><span id="TYPEdescriptiveCilPrinter"><span class="keyword">class type</span> <a href="Cil.descriptiveCilPrinter-c.html">descriptiveCilPrinter</a></span> = <code class="code">object</code> <a href="Cil.descriptiveCilPrinter-c.html">..</a> <code class="code">end</code></pre>
<pre><span id="TYPEdescriptiveCilPrinterClass"><span class="keyword">class</span> <a href="Cil.descriptiveCilPrinterClass-c.html">descriptiveCilPrinterClass</a></span> : <code class="type">bool -> </code><code class="type"><a href="Cil.descriptiveCilPrinter-c.html">descriptiveCilPrinter</a></code></pre><div class="info">
<p>Like defaultCilPrinterClass, but instead of temporary variable
    names it prints the description that was provided when the temp was
    created.</p>

</div>

<pre><span id="VALdescriptiveCilPrinter"><span class="keyword">val</span> descriptiveCilPrinter</span> : <code class="type"><a href="Cil.descriptiveCilPrinter-c.html">descriptiveCilPrinter</a></code></pre>
<pre><span id="VALprinterForMaincil"><span class="keyword">val</span> printerForMaincil</span> : <code class="type"><a href="Cil.cilPrinter-c.html">cilPrinter</a> ref</code></pre><div class="info ">
<div class="info-desc">
<p>zra: This is the pretty printer that Maincil will use.
    by default it is set to defaultCilPrinter</p>
</div>
</div>

<pre><span id="VALprintType"><span class="keyword">val</span> printType</span> : <code class="type"><a href="Cil.cilPrinter-c.html">cilPrinter</a> -> unit -> <a href="Cil.html#TYPEtyp">typ</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info ">
<div class="info-desc">
<p>Print a type given a pretty printer</p>
</div>
</div>

<pre><span id="VALprintExp"><span class="keyword">val</span> printExp</span> : <code class="type"><a href="Cil.cilPrinter-c.html">cilPrinter</a> -> unit -> <a href="Cil.html#TYPEexp">exp</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info ">
<div class="info-desc">
<p>Print an expression given a pretty printer</p>
</div>
</div>

<pre><span id="VALprintLval"><span class="keyword">val</span> printLval</span> : <code class="type"><a href="Cil.cilPrinter-c.html">cilPrinter</a> -> unit -> <a href="Cil.html#TYPElval">lval</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info ">
<div class="info-desc">
<p>Print an lvalue given a pretty printer</p>
</div>
</div>

<pre><span id="VALprintGlobal"><span class="keyword">val</span> printGlobal</span> : <code class="type"><a href="Cil.cilPrinter-c.html">cilPrinter</a> -> unit -> <a href="Cil.html#TYPEglobal">global</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info ">
<div class="info-desc">
<p>Print a global given a pretty printer</p>
</div>
</div>

<pre><span id="VALprintAttr"><span class="keyword">val</span> printAttr</span> : <code class="type"><a href="Cil.cilPrinter-c.html">cilPrinter</a> -> unit -> <a href="Cil.html#TYPEattribute">attribute</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info ">
<div class="info-desc">
<p>Print an attribute given a pretty printer</p>
</div>
</div>

<pre><span id="VALprintAttrs"><span class="keyword">val</span> printAttrs</span> : <code class="type"><a href="Cil.cilPrinter-c.html">cilPrinter</a> -> unit -> <a href="Cil.html#TYPEattributes">attributes</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info ">
<div class="info-desc">
<p>Print a set of attributes given a pretty printer</p>
</div>
</div>

<pre><span id="VALprintInstr"><span class="keyword">val</span> printInstr</span> : <code class="type"><a href="Cil.cilPrinter-c.html">cilPrinter</a> -> unit -> <a href="Cil.html#TYPEinstr">instr</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info ">
<div class="info-desc">
<p>Print an instruction given a pretty printer</p>
</div>
</div>

<pre><span id="VALprintStmt"><span class="keyword">val</span> printStmt</span> : <code class="type"><a href="Cil.cilPrinter-c.html">cilPrinter</a> -> unit -> <a href="Cil.html#TYPEstmt">stmt</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info ">
<div class="info-desc">
<p>Print a statement given a pretty printer. This can take very long
 (or even overflow the stack) for huge statements. Use <a href="Cil.html#VALdumpStmt"><code class="code">Cil.dumpStmt</code></a>
 instead.</p>
</div>
</div>

<pre><span id="VALprintBlock"><span class="keyword">val</span> printBlock</span> : <code class="type"><a href="Cil.cilPrinter-c.html">cilPrinter</a> -> unit -> <a href="Cil.html#TYPEblock">block</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info ">
<div class="info-desc">
<p>Print a block given a pretty printer. This can take very long
 (or even overflow the stack) for huge block. Use <a href="Cil.html#VALdumpBlock"><code class="code">Cil.dumpBlock</code></a>
 instead.</p>
</div>
</div>

<pre><span id="VALdumpStmt"><span class="keyword">val</span> dumpStmt</span> : <code class="type"><a href="Cil.cilPrinter-c.html">cilPrinter</a> -> out_channel -> int -> <a href="Cil.html#TYPEstmt">stmt</a> -> unit</code></pre><div class="info ">
<div class="info-desc">
<p>Dump a statement to a file using a given indentation. Use this instead of
 <a href="Cil.html#VALprintStmt"><code class="code">Cil.printStmt</code></a> whenever possible.</p>
</div>
</div>

<pre><span id="VALdumpBlock"><span class="keyword">val</span> dumpBlock</span> : <code class="type"><a href="Cil.cilPrinter-c.html">cilPrinter</a> -> out_channel -> int -> <a href="Cil.html#TYPEblock">block</a> -> unit</code></pre><div class="info ">
<div class="info-desc">
<p>Dump a block to a file using a given indentation. Use this instead of
 <a href="Cil.html#VALprintBlock"><code class="code">Cil.printBlock</code></a> whenever possible.</p>
</div>
</div>

<pre><span id="VALprintInit"><span class="keyword">val</span> printInit</span> : <code class="type"><a href="Cil.cilPrinter-c.html">cilPrinter</a> -> unit -> <a href="Cil.html#TYPEinit">init</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info ">
<div class="info-desc">
<p>Print an initializer given a pretty printer. This can take very long
 (or even overflow the stack) for huge initializers. Use <a href="Cil.html#VALdumpInit"><code class="code">Cil.dumpInit</code></a>
 instead.</p>
</div>
</div>

<pre><span id="VALdumpInit"><span class="keyword">val</span> dumpInit</span> : <code class="type"><a href="Cil.cilPrinter-c.html">cilPrinter</a> -> out_channel -> int -> <a href="Cil.html#TYPEinit">init</a> -> unit</code></pre><div class="info ">
<div class="info-desc">
<p>Dump an initializer to a file using a given indentation. Use this instead of
 <a href="Cil.html#VALprintInit"><code class="code">Cil.printInit</code></a> whenever possible.</p>
</div>
</div>

<pre><span id="VALd_type"><span class="keyword">val</span> d_type</span> : <code class="type">unit -> <a href="Cil.html#TYPEtyp">typ</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info ">
<div class="info-desc">
<p>Pretty-print a type using <a href="Cil.html#VALdefaultCilPrinter"><code class="code">Cil.defaultCilPrinter</code></a></p>
</div>
</div>

<pre><span id="VALd_exp"><span class="keyword">val</span> d_exp</span> : <code class="type">unit -> <a href="Cil.html#TYPEexp">exp</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info ">
<div class="info-desc">
<p>Pretty-print an expression using <a href="Cil.html#VALdefaultCilPrinter"><code class="code">Cil.defaultCilPrinter</code></a></p>
</div>
</div>

<pre><span id="VALd_lval"><span class="keyword">val</span> d_lval</span> : <code class="type">unit -> <a href="Cil.html#TYPElval">lval</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info ">
<div class="info-desc">
<p>Pretty-print an lvalue using <a href="Cil.html#VALdefaultCilPrinter"><code class="code">Cil.defaultCilPrinter</code></a></p>
</div>
</div>

<pre><span id="VALd_offset"><span class="keyword">val</span> d_offset</span> : <code class="type"><a href="Pretty.html#TYPEdoc">Pretty.doc</a> -> unit -> <a href="Cil.html#TYPEoffset">offset</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info ">
<div class="info-desc">
<p>Pretty-print an offset using <a href="Cil.html#VALdefaultCilPrinter"><code class="code">Cil.defaultCilPrinter</code></a>, given the pretty
 printing for the base.</p>
</div>
</div>

<pre><span id="VALd_init"><span class="keyword">val</span> d_init</span> : <code class="type">unit -> <a href="Cil.html#TYPEinit">init</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info ">
<div class="info-desc">
<p>Pretty-print an initializer using <a href="Cil.html#VALdefaultCilPrinter"><code class="code">Cil.defaultCilPrinter</code></a>.  This can be
 extremely slow (or even overflow the stack) for huge initializers. Use
 <a href="Cil.html#VALdumpInit"><code class="code">Cil.dumpInit</code></a> instead.</p>
</div>
</div>

<pre><span id="VALd_binop"><span class="keyword">val</span> d_binop</span> : <code class="type">unit -> <a href="Cil.html#TYPEbinop">binop</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info ">
<div class="info-desc">
<p>Pretty-print a binary operator</p>
</div>
</div>

<pre><span id="VALd_unop"><span class="keyword">val</span> d_unop</span> : <code class="type">unit -> <a href="Cil.html#TYPEunop">unop</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info ">
<div class="info-desc">
<p>Pretty-print a unary operator</p>
</div>
</div>

<pre><span id="VALd_attr"><span class="keyword">val</span> d_attr</span> : <code class="type">unit -> <a href="Cil.html#TYPEattribute">attribute</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info ">
<div class="info-desc">
<p>Pretty-print an attribute using <a href="Cil.html#VALdefaultCilPrinter"><code class="code">Cil.defaultCilPrinter</code></a></p>
</div>
</div>

<pre><span id="VALd_attrparam"><span class="keyword">val</span> d_attrparam</span> : <code class="type">unit -> <a href="Cil.html#TYPEattrparam">attrparam</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info ">
<div class="info-desc">
<p>Pretty-print an argument of an attribute using <a href="Cil.html#VALdefaultCilPrinter"><code class="code">Cil.defaultCilPrinter</code></a></p>
</div>
</div>

<pre><span id="VALd_attrlist"><span class="keyword">val</span> d_attrlist</span> : <code class="type">unit -> <a href="Cil.html#TYPEattributes">attributes</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info ">
<div class="info-desc">
<p>Pretty-print a list of attributes using <a href="Cil.html#VALdefaultCilPrinter"><code class="code">Cil.defaultCilPrinter</code></a></p>
</div>
</div>

<pre><span id="VALd_instr"><span class="keyword">val</span> d_instr</span> : <code class="type">unit -> <a href="Cil.html#TYPEinstr">instr</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info ">
<div class="info-desc">
<p>Pretty-print an instruction using <a href="Cil.html#VALdefaultCilPrinter"><code class="code">Cil.defaultCilPrinter</code></a></p>
</div>
</div>

<pre><span id="VALd_label"><span class="keyword">val</span> d_label</span> : <code class="type">unit -> <a href="Cil.html#TYPElabel">label</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info ">
<div class="info-desc">
<p>Pretty-print a label using <a href="Cil.html#VALdefaultCilPrinter"><code class="code">Cil.defaultCilPrinter</code></a></p>
</div>
</div>

<pre><span id="VALd_stmt"><span class="keyword">val</span> d_stmt</span> : <code class="type">unit -> <a href="Cil.html#TYPEstmt">stmt</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info ">
<div class="info-desc">
<p>Pretty-print a statement using <a href="Cil.html#VALdefaultCilPrinter"><code class="code">Cil.defaultCilPrinter</code></a>. This can be
 extremely slow (or even overflow the stack) for huge statements. Use
 <a href="Cil.html#VALdumpStmt"><code class="code">Cil.dumpStmt</code></a> instead.</p>
</div>
</div>

<pre><span id="VALd_block"><span class="keyword">val</span> d_block</span> : <code class="type">unit -> <a href="Cil.html#TYPEblock">block</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info ">
<div class="info-desc">
<p>Pretty-print a block using <a href="Cil.html#VALdefaultCilPrinter"><code class="code">Cil.defaultCilPrinter</code></a>. This can be
 extremely slow (or even overflow the stack) for huge blocks. Use
 <a href="Cil.html#VALdumpBlock"><code class="code">Cil.dumpBlock</code></a> instead.</p>
</div>
</div>

<pre><span id="VALd_global"><span class="keyword">val</span> d_global</span> : <code class="type">unit -> <a href="Cil.html#TYPEglobal">global</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info ">
<div class="info-desc">
<p>Pretty-print the internal representation of a global using
 <a href="Cil.html#VALdefaultCilPrinter"><code class="code">Cil.defaultCilPrinter</code></a>. This can be extremely slow (or even overflow the
 stack) for huge globals (such as arrays with lots of initializers). Use
 <a href="Cil.html#VALdumpGlobal"><code class="code">Cil.dumpGlobal</code></a> instead.</p>
</div>
</div>

<pre><span id="VALdn_exp"><span class="keyword">val</span> dn_exp</span> : <code class="type">unit -> <a href="Cil.html#TYPEexp">exp</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info ">
<div class="info-desc">
<p>Versions of the above pretty printers, that don't print #line directives</p>
</div>
</div>

<pre><span id="VALdn_lval"><span class="keyword">val</span> dn_lval</span> : <code class="type">unit -> <a href="Cil.html#TYPElval">lval</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre>
<pre><span id="VALdn_init"><span class="keyword">val</span> dn_init</span> : <code class="type">unit -> <a href="Cil.html#TYPEinit">init</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre>
<pre><span id="VALdn_type"><span class="keyword">val</span> dn_type</span> : <code class="type">unit -> <a href="Cil.html#TYPEtyp">typ</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre>
<pre><span id="VALdn_global"><span class="keyword">val</span> dn_global</span> : <code class="type">unit -> <a href="Cil.html#TYPEglobal">global</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre>
<pre><span id="VALdn_attrlist"><span class="keyword">val</span> dn_attrlist</span> : <code class="type">unit -> <a href="Cil.html#TYPEattributes">attributes</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre>
<pre><span id="VALdn_attr"><span class="keyword">val</span> dn_attr</span> : <code class="type">unit -> <a href="Cil.html#TYPEattribute">attribute</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre>
<pre><span id="VALdn_attrparam"><span class="keyword">val</span> dn_attrparam</span> : <code class="type">unit -> <a href="Cil.html#TYPEattrparam">attrparam</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre>
<pre><span id="VALdn_stmt"><span class="keyword">val</span> dn_stmt</span> : <code class="type">unit -> <a href="Cil.html#TYPEstmt">stmt</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre>
<pre><span id="VALdn_instr"><span class="keyword">val</span> dn_instr</span> : <code class="type">unit -> <a href="Cil.html#TYPEinstr">instr</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre>
<pre><span id="VALd_shortglobal"><span class="keyword">val</span> d_shortglobal</span> : <code class="type">unit -> <a href="Cil.html#TYPEglobal">global</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info ">
<div class="info-desc">
<p>Pretty-print a short description of the global. This is useful for error
 messages</p>
</div>
</div>

<pre><span id="VALdumpGlobal"><span class="keyword">val</span> dumpGlobal</span> : <code class="type"><a href="Cil.cilPrinter-c.html">cilPrinter</a> -> out_channel -> <a href="Cil.html#TYPEglobal">global</a> -> unit</code></pre><div class="info ">
<div class="info-desc">
<p>Pretty-print a global. Here you give the channel where the printout
 should be sent.</p>
</div>
</div>

<pre><span id="VALdumpFile"><span class="keyword">val</span> dumpFile</span> : <code class="type"><a href="Cil.cilPrinter-c.html">cilPrinter</a> -> out_channel -> string -> <a href="Cil.html#TYPEfile">file</a> -> unit</code></pre><div class="info ">
<div class="info-desc">
<p>Pretty-print an entire file. Here you give the channel where the printout
 should be sent.</p>
</div>
</div>
<p>the following error message producing functions also print a location in
 the code. use <a href="Errormsg.html#VALbug"><code class="code">Errormsg.bug</code></a> and <a href="Errormsg.html#VALunimp"><code class="code">Errormsg.unimp</code></a> if you do not want
 that</p>

<pre><span id="VALbug"><span class="keyword">val</span> bug</span> : <code class="type">('a, unit, <a href="Pretty.html#TYPEdoc">Pretty.doc</a>) format -> 'a</code></pre><div class="info ">
<div class="info-desc">
<p>Like <a href="Errormsg.html#VALbug"><code class="code">Errormsg.bug</code></a> except that <a href="Cil.html#VALcurrentLoc"><code class="code">Cil.currentLoc</code></a> is also printed</p>
</div>
</div>

<pre><span id="VALunimp"><span class="keyword">val</span> unimp</span> : <code class="type">('a, unit, <a href="Pretty.html#TYPEdoc">Pretty.doc</a>) format -> 'a</code></pre><div class="info ">
<div class="info-desc">
<p>Like <a href="Errormsg.html#VALunimp"><code class="code">Errormsg.unimp</code></a> except that <a href="Cil.html#VALcurrentLoc"><code class="code">Cil.currentLoc</code></a>is also printed</p>
</div>
</div>

<pre><span id="VALerror"><span class="keyword">val</span> error</span> : <code class="type">('a, unit, <a href="Pretty.html#TYPEdoc">Pretty.doc</a>) format -> 'a</code></pre><div class="info ">
<div class="info-desc">
<p>Like <a href="Errormsg.html#VALerror"><code class="code">Errormsg.error</code></a> except that <a href="Cil.html#VALcurrentLoc"><code class="code">Cil.currentLoc</code></a> is also printed</p>
</div>
</div>

<pre><span id="VALerrorLoc"><span class="keyword">val</span> errorLoc</span> : <code class="type"><a href="Cil.html#TYPElocation">location</a> -> ('a, unit, <a href="Pretty.html#TYPEdoc">Pretty.doc</a>) format -> 'a</code></pre><div class="info ">
<div class="info-desc">
<p>Like <a href="Cil.html#VALerror"><code class="code">Cil.error</code></a> except that it explicitly takes a location argument,
 instead of using the <a href="Cil.html#VALcurrentLoc"><code class="code">Cil.currentLoc</code></a></p>
</div>
</div>

<pre><span id="VALwarn"><span class="keyword">val</span> warn</span> : <code class="type">('a, unit, <a href="Pretty.html#TYPEdoc">Pretty.doc</a>) format -> 'a</code></pre><div class="info ">
<div class="info-desc">
<p>Like <a href="Errormsg.html#VALwarn"><code class="code">Errormsg.warn</code></a> except that <a href="Cil.html#VALcurrentLoc"><code class="code">Cil.currentLoc</code></a> is also printed</p>
</div>
</div>

<pre><span id="VALwarnOpt"><span class="keyword">val</span> warnOpt</span> : <code class="type">('a, unit, <a href="Pretty.html#TYPEdoc">Pretty.doc</a>) format -> 'a</code></pre><div class="info ">
<div class="info-desc">
<p>Like <a href="Errormsg.html#VALwarnOpt"><code class="code">Errormsg.warnOpt</code></a> except that <a href="Cil.html#VALcurrentLoc"><code class="code">Cil.currentLoc</code></a> is also printed.
 This warning is printed only of <a href="Errormsg.html#VALwarnFlag"><code class="code">Errormsg.warnFlag</code></a> is set.</p>
</div>
</div>

<pre><span id="VALwarnContext"><span class="keyword">val</span> warnContext</span> : <code class="type">('a, unit, <a href="Pretty.html#TYPEdoc">Pretty.doc</a>) format -> 'a</code></pre><div class="info ">
<div class="info-desc">
<p>Like <a href="Errormsg.html#VALwarn"><code class="code">Errormsg.warn</code></a> except that <a href="Cil.html#VALcurrentLoc"><code class="code">Cil.currentLoc</code></a> and context
    is also printed</p>
</div>
</div>

<pre><span id="VALwarnContextOpt"><span class="keyword">val</span> warnContextOpt</span> : <code class="type">('a, unit, <a href="Pretty.html#TYPEdoc">Pretty.doc</a>) format -> 'a</code></pre><div class="info ">
<div class="info-desc">
<p>Like <a href="Errormsg.html#VALwarn"><code class="code">Errormsg.warn</code></a> except that <a href="Cil.html#VALcurrentLoc"><code class="code">Cil.currentLoc</code></a> and context is also
 printed. This warning is printed only of <a href="Errormsg.html#VALwarnFlag"><code class="code">Errormsg.warnFlag</code></a> is set.</p>
</div>
</div>

<pre><span id="VALwarnLoc"><span class="keyword">val</span> warnLoc</span> : <code class="type"><a href="Cil.html#TYPElocation">location</a> -> ('a, unit, <a href="Pretty.html#TYPEdoc">Pretty.doc</a>) format -> 'a</code></pre><div class="info ">
<div class="info-desc">
<p>Like <a href="Cil.html#VALwarn"><code class="code">Cil.warn</code></a> except that it explicitly takes a location argument,
 instead of using the <a href="Cil.html#VALcurrentLoc"><code class="code">Cil.currentLoc</code></a></p>
</div>
</div>
<p>Sometimes you do not want to see the syntactic sugar that the above
 pretty-printing functions add. In that case you can use the following
 pretty-printing functions. But note that the output of these functions is
 not valid C</p>

<pre><span id="VALd_plainexp"><span class="keyword">val</span> d_plainexp</span> : <code class="type">unit -> <a href="Cil.html#TYPEexp">exp</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info ">
<div class="info-desc">
<p>Pretty-print the internal representation of an expression</p>
</div>
</div>

<pre><span id="VALd_plaininit"><span class="keyword">val</span> d_plaininit</span> : <code class="type">unit -> <a href="Cil.html#TYPEinit">init</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info ">
<div class="info-desc">
<p>Pretty-print the internal representation of an integer</p>
</div>
</div>

<pre><span id="VALd_plainlval"><span class="keyword">val</span> d_plainlval</span> : <code class="type">unit -> <a href="Cil.html#TYPElval">lval</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info ">
<div class="info-desc">
<p>Pretty-print the internal representation of an lvalue</p>
</div>
</div>
<p>Pretty-print the internal representation of an lvalue offset
    val d_plainoffset: unit -&gt; offset -&gt; Pretty.doc</p>

<pre><span id="VALd_plaintype"><span class="keyword">val</span> d_plaintype</span> : <code class="type">unit -> <a href="Cil.html#TYPEtyp">typ</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info ">
<div class="info-desc">
<p>Pretty-print the internal representation of a type</p>
</div>
</div>

<pre><span id="VALdd_exp"><span class="keyword">val</span> dd_exp</span> : <code class="type">unit -> <a href="Cil.html#TYPEexp">exp</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info ">
<div class="info-desc">
<p>Pretty-print an expression while printing descriptions rather than names
    of temporaries.</p>

<p>Pretty-print an lvalue on the left side of an assignment.
    If there is an offset or memory dereference, temporaries will
    be replaced by descriptions as in dd_exp.  If the lval is a temp var,
    that var will not be replaced by a description; use "dd_exp () (Lval lv)"
    if that's what you want.</p>
</div>
</div>

<pre><span id="VALdd_lval"><span class="keyword">val</span> dd_lval</span> : <code class="type">unit -> <a href="Cil.html#TYPElval">lval</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><p><b>ALPHA conversion</b> has been moved to the Alpha module.</p>

<pre><span id="VALuniqueVarNames"><span class="keyword">val</span> uniqueVarNames</span> : <code class="type"><a href="Cil.html#TYPEfile">file</a> -> unit</code></pre><div class="info ">
<div class="info-desc">
<p>Assign unique names to local variables. This might be necessary after you
 transformed the code and added or renamed some new variables. Names are
 not used by CIL internally, but once you print the file out the compiler
 downstream might be confused. You might
 have added a new global that happens to have the same name as a local in
 some function. Rename the local to ensure that there would never be
 confusioin. Or, viceversa, you might have added a local with a name that
 conflicts with a global</p>
</div>
</div>
<p><b>Optimization Passes</b></p>

<pre><span id="VALpeepHole2"><span class="keyword">val</span> peepHole2</span> : <code class="type">(<a href="Cil.html#TYPEinstr">instr</a> * <a href="Cil.html#TYPEinstr">instr</a> -> <a href="Cil.html#TYPEinstr">instr</a> list option) -> <a href="Cil.html#TYPEstmt">stmt</a> list -> unit</code></pre><div class="info ">
<div class="info-desc">
<p>A peephole optimizer that processes two adjacent instructions and possibly
    replaces them both. If some replacement happens, then the new instructions
    are themselves subject to optimization</p>
</div>
</div>

<pre><span id="VALpeepHole1"><span class="keyword">val</span> peepHole1</span> : <code class="type">(<a href="Cil.html#TYPEinstr">instr</a> -> <a href="Cil.html#TYPEinstr">instr</a> list option) -> <a href="Cil.html#TYPEstmt">stmt</a> list -> unit</code></pre><div class="info ">
<div class="info-desc">
<p>Similar to <code class="code">peepHole2</code> except that the optimization window consists of
    one instruction, not two</p>
</div>
</div>
<p><b>Machine dependency</b></p>

<pre><span id="EXCEPTIONSizeOfError"><span class="keyword">exception</span> SizeOfError</span> <span class="keyword">of</span> <code class="type">string * <a href="Cil.html#TYPEtyp">typ</a></code></pre>
<div class="info ">
<div class="info-desc">
<p>Raised when one of the bitsSizeOf functions cannot compute the size of a
 type. This can happen because the type contains array-length expressions
 that we don't know how to compute or because it is a type whose size is
 not defined (e.g. TFun or an undefined compinfo). The string is an
 explanation of the error</p>
</div>
</div>

<pre><span id="VALunsignedVersionOf"><span class="keyword">val</span> unsignedVersionOf</span> : <code class="type"><a href="Cil.html#TYPEikind">ikind</a> -> <a href="Cil.html#TYPEikind">ikind</a></code></pre><div class="info ">
<div class="info-desc">
<p>Give the unsigned kind corresponding to any integer kind</p>
</div>
</div>

<pre><span id="VALsignedVersionOf"><span class="keyword">val</span> signedVersionOf</span> : <code class="type"><a href="Cil.html#TYPEikind">ikind</a> -> <a href="Cil.html#TYPEikind">ikind</a></code></pre><div class="info ">
<div class="info-desc">
<p>Give the signed kind corresponding to any integer kind</p>
</div>
</div>

<pre><span id="VALintRank"><span class="keyword">val</span> intRank</span> : <code class="type"><a href="Cil.html#TYPEikind">ikind</a> -> int</code></pre><div class="info ">
<div class="info-desc">
<p>Return the integer conversion rank of an integer kind</p>
</div>
</div>

<pre><span id="VALcommonIntKind"><span class="keyword">val</span> commonIntKind</span> : <code class="type"><a href="Cil.html#TYPEikind">ikind</a> -> <a href="Cil.html#TYPEikind">ikind</a> -> <a href="Cil.html#TYPEikind">ikind</a></code></pre><div class="info ">
<div class="info-desc">
<p>Return the common integer kind of the two integer arguments, as
    defined in ISO C 6.3.1.8 ("Usual arithmetic conversions")</p>
</div>
</div>

<pre><span id="VALintKindForSize"><span class="keyword">val</span> intKindForSize</span> : <code class="type">int -> bool -> <a href="Cil.html#TYPEikind">ikind</a></code></pre><div class="info ">
<div class="info-desc">
<p>The signed integer kind for a given size (unsigned if second argument
 is true). Raises Not_found if no such kind exists</p>
</div>
</div>

<pre><span id="VALfloatKindForSize"><span class="keyword">val</span> floatKindForSize</span> : <code class="type">int -> <a href="Cil.html#TYPEfkind">fkind</a></code></pre><div class="info ">
<div class="info-desc">
<p>The float kind for a given size. Raises Not_found
  if no such kind exists</p>
</div>
</div>

<pre><span id="VALbytesSizeOfInt"><span class="keyword">val</span> bytesSizeOfInt</span> : <code class="type"><a href="Cil.html#TYPEikind">ikind</a> -> int</code></pre><div class="info ">
<div class="info-desc">
<p>The size in bytes of the given int kind.</p>
</div>
</div>

<pre><span id="VALbitsSizeOf"><span class="keyword">val</span> bitsSizeOf</span> : <code class="type"><a href="Cil.html#TYPEtyp">typ</a> -> int</code></pre><div class="info ">
<div class="info-desc">
<p>The size of a type, in bits. Trailing padding is added for structs and
 arrays. Raises <a href="Cil.html#EXCEPTIONSizeOfError"><code class="code">Cil.SizeOfError</code></a> when it cannot compute the size. This
 function is architecture dependent, so you should only call this after you
 call <a href="Cil.html#VALinitCIL"><code class="code">Cil.initCIL</code></a>. Remember that on GCC sizeof(void) is 1!</p>
</div>
</div>

<pre><span id="VALtruncateCilint"><span class="keyword">val</span> truncateCilint</span> : <code class="type"><a href="Cil.html#TYPEikind">ikind</a> -> Cilint.cilint -> Cilint.cilint * Cilint.truncation</code></pre><div class="info ">
<div class="info-desc">
<p>Represents an integer as for a given kind.  Returns a truncation
 flag saying that the value fit in the kind (NoTruncation), didn't
 fit but no "interesting" bits (all-0 or all-1) were lost
 (ValueTruncation) or that bits were lost (BitTruncation). Another
 way to look at the ValueTruncation result is that if you had used
 the kind of opposite signedness (e.g. IUInt rather than IInt), you
 would gave got NoTruncation...</p>
</div>
</div>

<pre><span id="VALfitsInInt"><span class="keyword">val</span> fitsInInt</span> : <code class="type"><a href="Cil.html#TYPEikind">ikind</a> -> Cilint.cilint -> bool</code></pre><div class="info ">
<div class="info-desc">
<p>True if the integer fits within the kind's range</p>
</div>
</div>

<pre><span id="VALintKindForValue"><span class="keyword">val</span> intKindForValue</span> : <code class="type">Cilint.cilint -> bool -> <a href="Cil.html#TYPEikind">ikind</a></code></pre><div class="info ">
<div class="info-desc">
<p>Return the smallest kind that will hold the integer's value.  The
 kind will be unsigned if the 2nd argument is true, signed
 otherwise.  Note that if the value doesn't fit in any of the
 available types, you will get ILongLong (2nd argument false) or
 IULongLong (2nd argument true).</p>
</div>
</div>

<pre><span id="VALmkCilint"><span class="keyword">val</span> mkCilint</span> : <code class="type"><a href="Cil.html#TYPEikind">ikind</a> -> int64 -> Cilint.cilint</code></pre><div class="info ">
<div class="info-desc">
<p>Construct a cilint from an integer kind and int64 value. Used for
 getting the actual constant value from a CInt64(n, ik, _)
 constant.</p>
</div>
</div>

<pre><span id="VALsizeOf"><span class="keyword">val</span> sizeOf</span> : <code class="type"><a href="Cil.html#TYPEtyp">typ</a> -> <a href="Cil.html#TYPEexp">exp</a></code></pre><div class="info ">
<div class="info-desc">
<p>The size of a type, in bytes. Returns a constant expression or a
 "sizeof" expression if it cannot compute the size. This function
 is architecture dependent, so you should only call this after you
 call <a href="Cil.html#VALinitCIL"><code class="code">Cil.initCIL</code></a>.</p>
</div>
</div>

<pre><span id="VALalignOf_int"><span class="keyword">val</span> alignOf_int</span> : <code class="type"><a href="Cil.html#TYPEtyp">typ</a> -> int</code></pre><div class="info ">
<div class="info-desc">
<p>The minimum alignment (in bytes) for a type. This function is
 architecture dependent, so you should only call this after you call
 <a href="Cil.html#VALinitCIL"><code class="code">Cil.initCIL</code></a>.</p>
</div>
</div>

<pre><span id="VALbitsOffset"><span class="keyword">val</span> bitsOffset</span> : <code class="type"><a href="Cil.html#TYPEtyp">typ</a> -> <a href="Cil.html#TYPEoffset">offset</a> -> int * int</code></pre><div class="info ">
<div class="info-desc">
<p>Give a type of a base and an offset, returns the number of bits from the
 base address and the width (also expressed in bits) for the subobject
 denoted by the offset. Raises <a href="Cil.html#EXCEPTIONSizeOfError"><code class="code">Cil.SizeOfError</code></a> when it cannot compute
 the size. This function is architecture dependent, so you should only call
 this after you call <a href="Cil.html#VALinitCIL"><code class="code">Cil.initCIL</code></a>.</p>
</div>
</div>

<pre><span id="VALchar_is_unsigned"><span class="keyword">val</span> char_is_unsigned</span> : <code class="type">bool ref</code></pre><div class="info ">
<div class="info-desc">
<p>Whether "char" is unsigned. Set after you call <a href="Cil.html#VALinitCIL"><code class="code">Cil.initCIL</code></a></p>
</div>
</div>

<pre><span id="VALlittle_endian"><span class="keyword">val</span> little_endian</span> : <code class="type">bool ref</code></pre><div class="info ">
<div class="info-desc">
<p>Whether the machine is little endian. Set after you call <a href="Cil.html#VALinitCIL"><code class="code">Cil.initCIL</code></a></p>
</div>
</div>

<pre><span id="VALunderscore_name"><span class="keyword">val</span> underscore_name</span> : <code class="type">bool ref</code></pre><div class="info ">
<div class="info-desc">
<p>Whether the compiler generates assembly labels by prepending "_" to the
    identifier. That is, will function foo() have the label "foo", or "_foo"?
    Set after you call <a href="Cil.html#VALinitCIL"><code class="code">Cil.initCIL</code></a></p>
</div>
</div>

<pre><span id="VALlocUnknown"><span class="keyword">val</span> locUnknown</span> : <code class="type"><a href="Cil.html#TYPElocation">location</a></code></pre><div class="info ">
<div class="info-desc">
<p>Represents a location that cannot be determined</p>
</div>
</div>

<pre><span id="VALget_instrLoc"><span class="keyword">val</span> get_instrLoc</span> : <code class="type"><a href="Cil.html#TYPEinstr">instr</a> -> <a href="Cil.html#TYPElocation">location</a></code></pre><div class="info ">
<div class="info-desc">
<p>Return the location of an instruction</p>
</div>
</div>

<pre><span id="VALget_globalLoc"><span class="keyword">val</span> get_globalLoc</span> : <code class="type"><a href="Cil.html#TYPEglobal">global</a> -> <a href="Cil.html#TYPElocation">location</a></code></pre><div class="info ">
<div class="info-desc">
<p>Return the location of a global, or locUnknown</p>
</div>
</div>

<pre><span id="VALget_stmtLoc"><span class="keyword">val</span> get_stmtLoc</span> : <code class="type"><a href="Cil.html#TYPEstmtkind">stmtkind</a> -> <a href="Cil.html#TYPElocation">location</a></code></pre><div class="info ">
<div class="info-desc">
<p>Return the location of a statement, or locUnknown</p>
</div>
</div>

<pre><span id="VALdExp"><span class="keyword">val</span> dExp</span> : <code class="type"><a href="Pretty.html#TYPEdoc">Pretty.doc</a> -> <a href="Cil.html#TYPEexp">exp</a></code></pre><div class="info ">
<div class="info-desc">
<p>Generate an <a href="Cil.html#TYPEexp"><code class="code">Cil.exp</code></a> to be used in case of errors.</p>
</div>
</div>

<pre><span id="VALdInstr"><span class="keyword">val</span> dInstr</span> : <code class="type"><a href="Pretty.html#TYPEdoc">Pretty.doc</a> -> <a href="Cil.html#TYPElocation">location</a> -> <a href="Cil.html#TYPEinstr">instr</a></code></pre><div class="info ">
<div class="info-desc">
<p>Generate an <a href="Cil.html#TYPEinstr"><code class="code">Cil.instr</code></a> to be used in case of errors.</p>
</div>
</div>

<pre><span id="VALdGlobal"><span class="keyword">val</span> dGlobal</span> : <code class="type"><a href="Pretty.html#TYPEdoc">Pretty.doc</a> -> <a href="Cil.html#TYPElocation">location</a> -> <a href="Cil.html#TYPEglobal">global</a></code></pre><div class="info ">
<div class="info-desc">
<p>Generate a <a href="Cil.html#TYPEglobal"><code class="code">Cil.global</code></a> to be used in case of errors.</p>
</div>
</div>

<pre><span id="VALmapNoCopy"><span class="keyword">val</span> mapNoCopy</span> : <code class="type">('a -> 'a) -> 'a list -> 'a list</code></pre><div class="info ">
<div class="info-desc">
<p>Like map but try not to make a copy of the list</p>
</div>
</div>

<pre><span id="VALmapNoCopyList"><span class="keyword">val</span> mapNoCopyList</span> : <code class="type">('a -> 'a list) -> 'a list -> 'a list</code></pre><div class="info ">
<div class="info-desc">
<p>Like map but each call can return a list. Try not to make a copy of the
    list</p>
</div>
</div>

<pre><span id="VALstartsWith"><span class="keyword">val</span> startsWith</span> : <code class="type">string -> string -> bool</code></pre><div class="info ">
<div class="info-desc">
<p>sm: return true if the first is a prefix of the second string</p>
</div>
</div>

<pre><span id="VALendsWith"><span class="keyword">val</span> endsWith</span> : <code class="type">string -> string -> bool</code></pre><div class="info ">
<div class="info-desc">
<p>return true if the first is a suffix of the second string</p>
</div>
</div>

<pre><span id="VALstripUnderscores"><span class="keyword">val</span> stripUnderscores</span> : <code class="type">string -> string</code></pre><div class="info ">
<div class="info-desc">
<p>If string has leading and trailing __, strip them.</p>
</div>
</div>
<p><b>An Interpreter for constructing CIL constructs</b></p>

<pre><code><span id="TYPEformatArg"><span class="keyword">type</span> <code class="type"></code>formatArg</span> = </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTformatArg.Fe"><span class="constructor">Fe</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEexp">exp</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTformatArg.Feo"><span class="constructor">Feo</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEexp">exp</a> option</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>For array lengths</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTformatArg.Fu"><span class="constructor">Fu</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEunop">unop</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTformatArg.Fb"><span class="constructor">Fb</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEbinop">binop</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTformatArg.Fk"><span class="constructor">Fk</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEikind">ikind</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTformatArg.FE"><span class="constructor">FE</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEexp">exp</a> list</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>For arguments in a function call</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTformatArg.Ff"><span class="constructor">Ff</span></span> <span class="keyword">of</span> <code class="type">(string * <a href="Cil.html#TYPEtyp">typ</a> * <a href="Cil.html#TYPEattributes">attributes</a>)</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>For a formal argument</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTformatArg.FF"><span class="constructor">FF</span></span> <span class="keyword">of</span> <code class="type">(string * <a href="Cil.html#TYPEtyp">typ</a> * <a href="Cil.html#TYPEattributes">attributes</a>) list</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>For formal argument lists</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTformatArg.Fva"><span class="constructor">Fva</span></span> <span class="keyword">of</span> <code class="type">bool</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>For the ellipsis in a function type</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTformatArg.Fv"><span class="constructor">Fv</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEvarinfo">varinfo</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTformatArg.Fl"><span class="constructor">Fl</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPElval">lval</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTformatArg.Flo"><span class="constructor">Flo</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPElval">lval</a> option</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTformatArg.Fo"><span class="constructor">Fo</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEoffset">offset</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTformatArg.Fc"><span class="constructor">Fc</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEcompinfo">compinfo</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTformatArg.Fi"><span class="constructor">Fi</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEinstr">instr</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTformatArg.FI"><span class="constructor">FI</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEinstr">instr</a> list</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTformatArg.Ft"><span class="constructor">Ft</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEtyp">typ</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTformatArg.Fd"><span class="constructor">Fd</span></span> <span class="keyword">of</span> <code class="type">int</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTformatArg.Fg"><span class="constructor">Fg</span></span> <span class="keyword">of</span> <code class="type">string</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTformatArg.Fs"><span class="constructor">Fs</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEstmt">stmt</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTformatArg.FS"><span class="constructor">FS</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEstmt">stmt</a> list</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTformatArg.FA"><span class="constructor">FA</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEattributes">attributes</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTformatArg.Fp"><span class="constructor">Fp</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEattrparam">attrparam</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTformatArg.FP"><span class="constructor">FP</span></span> <span class="keyword">of</span> <code class="type"><a href="Cil.html#TYPEattrparam">attrparam</a> list</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTformatArg.FX"><span class="constructor">FX</span></span> <span class="keyword">of</span> <code class="type">string</code></code></td>

</tr></table>

<div class="info ">
<div class="info-desc">
<p>The type of argument for the interpreter</p>
</div>
</div>


<pre><span id="VALd_formatarg"><span class="keyword">val</span> d_formatarg</span> : <code class="type">unit -> <a href="Cil.html#TYPEformatArg">formatArg</a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc</a></code></pre><div class="info ">
<div class="info-desc">
<p>Pretty-prints a format arg</p>
</div>
</div>

<pre><span id="VALwarnTruncate"><span class="keyword">val</span> warnTruncate</span> : <code class="type">bool ref</code></pre><div class="info ">
<div class="info-desc">
<p>Emit warnings when truncating integer constants (default true)</p>
</div>
</div>

<pre><span id="VALenvMachine"><span class="keyword">val</span> envMachine</span> : <code class="type">Machdep.mach option ref</code></pre><div class="info ">
<div class="info-desc">
<p>Machine model specified via CIL_MACHINE environment variable</p>
</div>
</div>

<pre><span id="VALconvertInts"><span class="keyword">val</span> convertInts</span> : <code class="type">int64 -> <a href="Cil.html#TYPEikind">ikind</a> -> int64 -> <a href="Cil.html#TYPEikind">ikind</a> -> int64 * int64 * <a href="Cil.html#TYPEikind">ikind</a></code></pre><div class="info ">
<div class="info-deprecated">
<span class="warning">Deprecated.</span>. Convert two int64/kind pairs to a common int64/int64/kind triple.</div>
</div>

<pre><span id="VALisInteger"><span class="keyword">val</span> isInteger</span> : <code class="type"><a href="Cil.html#TYPEexp">exp</a> -> int64 option</code></pre><div class="info ">
<div class="info-deprecated">
<span class="warning">Deprecated.</span>. Can't handle large 64-bit unsigned constants
    correctly - use getInteger instead. If the given expression
    is a (possibly cast'ed) character or an integer constant, return
    that integer.  Otherwise, return None.</div>
</div>

<pre><span id="VALtruncateInteger64"><span class="keyword">val</span> truncateInteger64</span> : <code class="type"><a href="Cil.html#TYPEikind">ikind</a> -> int64 -> int64 * bool</code></pre><div class="info ">
<div class="info-deprecated">
<span class="warning">Deprecated.</span>. Use truncateCilint instead. Represents an integer as
 for a given kind.  Returns a flag saying whether the value was
 changed during truncation (because it was too large to fit in k).</div>
</div>

<pre><span id="VALgccBuiltins"><span class="keyword">val</span> gccBuiltins</span> : <code class="type">(string, <a href="Cil.html#TYPEtyp">typ</a> * <a href="Cil.html#TYPEtyp">typ</a> list * bool) Hashtbl.t</code></pre><div class="info ">
<div class="info-deprecated">
<span class="warning">Deprecated.</span>.  For compatibility with older programs, these are
    aliases for <a href="Cil.html#VALbuiltinFunctions"><code class="code">Cil.builtinFunctions</code></a></div>
</div>

<pre><span id="VALmsvcBuiltins"><span class="keyword">val</span> msvcBuiltins</span> : <code class="type">(string, <a href="Cil.html#TYPEtyp">typ</a> * <a href="Cil.html#TYPEtyp">typ</a> list * bool) Hashtbl.t</code></pre><div class="info ">
<div class="info-deprecated">
<span class="warning">Deprecated.</span>.  For compatibility with older programs, these are
    aliases for <a href="Cil.html#VALbuiltinFunctions"><code class="code">Cil.builtinFunctions</code></a></div>
</div>
</body></html>